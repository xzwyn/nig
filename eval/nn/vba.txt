Option Explicit

' =========================================
' CONFIG
' =========================================
Private Const CONVERTAPI_SECRET As String = "NNIZCBIm0yTAqX3pGHHuZUKsCuMeWhJn"   ' <-- Replace with your actual key
Private Const ENABLE_DEFRAG As Boolean = True
Private Const DEFRAG_MIN_CHARS As Long = 120
Private Const DEFRAG_SENT_ENDS As String = ".?!:;)""]"

Private Const PENALTY_1x2 As Double = 12#
Private Const PENALTY_2x1 As Double = 12#
Private Const PENALTY_2x2 As Double = 20#
Private Const PENALTY_SKIP_BASE As Double = 120#
Private Const PENALTY_SKIP_PER_CHAR As Double = 0.4

Private Enum AlignAction
    act_Invalid = 0
    act_1x1 = 1
    act_1x2 = 2
    act_2x1 = 3
    act_2x2 = 4
    act_SkipEN = 5
    act_SkipDE = 6
End Enum


' =========================================
' 1) PICK FILE DIALOG
' =========================================
Private Function BrowseForFile(prompt As String) As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = prompt
        .Filters.Clear
        .Filters.Add "PDF Files", "*.pdf"
        .AllowMultiSelect = False
        If .Show <> -1 Then Exit Function
        BrowseForFile = .SelectedItems(1)
    End With
End Function


' =========================================
' 2) CALL CONVERTAPI (PDF ? DOCX)
' ==============================
Private Function ConvertPdfToWord_ConvertAPI(pdfPath As String) As String
    Dim http As Object
    Dim url As String
    Dim boundary As String
    Dim fileBytes() As Byte
    Dim fNum As Integer
    Dim jsonResp As String
    Dim base64Str As String
    Dim tmpDocx As String
    Dim stream As Object

    If Dir$(pdfPath) = "" Then
        MsgBox "PDF not found: " & pdfPath, vbCritical
        Exit Function
    End If

    url = "https://v2.convertapi.com/convert/pdf/to/docx?Secret=" & CONVERTAPI_SECRET
    boundary = "----VBAFormBoundary" & Hex(Timer * 1000)

    ' 1) read PDF into bytes
    fNum = FreeFile
    Open pdfPath For Binary As #fNum
    ReDim fileBytes(LOF(fNum) - 1)
    Get #fNum, , fileBytes
    Close #fNum

    ' 2) build multipart/form-data in a stream
    Set stream = CreateObject("ADODB.Stream")
    stream.Type = 1   'adTypeBinary
    stream.Open

    ' ConvertAPI expects *File* (capital F)
    WriteStringToStream stream, "--" & boundary & vbCrLf
    WriteStringToStream stream, _
        "Content-Disposition: form-data; name=""File""; filename=""" & GetFileName(pdfPath) & """" & vbCrLf
    WriteStringToStream stream, "Content-Type: application/pdf" & vbCrLf & vbCrLf
    stream.Write fileBytes
    WriteStringToStream stream, vbCrLf & "--" & boundary & "--" & vbCrLf

    ' IMPORTANT: rewind stream before sending
    stream.Position = 0

    ' 3) send request
    Set http = CreateObject("WinHttp.WinHttpRequest.5.1")
    http.Open "POST", url, False
    http.SetRequestHeader "Content-Type", "multipart/form-data; boundary=" & boundary
    http.Send stream.Read  ' now it sends the full body

    If http.Status <> 200 Then
        MsgBox "ConvertAPI error: " & http.Status & vbCrLf & http.ResponseText, vbCritical
        Exit Function
    End If

    jsonResp = http.ResponseText

    ' 4) get base64
    base64Str = GetJsonValue(jsonResp, "FileData")
    If Len(base64Str) = 0 Then
        MsgBox "ConvertAPI: no FileData found in response." & vbCrLf & jsonResp, vbCritical
        Exit Function
    End If

    ' 5) save to temp docx
    tmpDocx = Environ$("TEMP") & "\" & "conv_" & Format(Now, "yyyymmdd_hhnnss") & "_" & Int(Rnd * 10000) & ".docx"

    If Base64ToFile(base64Str, tmpDocx) Then
        ConvertPdfToWord_ConvertAPI = tmpDocx
    Else
        MsgBox "Failed to write DOCX file.", vbCritical
    End If
End Function



' =========================================
' 3) HELPER FUNCTIONS
' =========================================
Private Sub WriteStringToStream(stm As Object, txt As String)
    Dim B() As Byte
    B = StrConv(txt, vbFromUnicode)
    stm.Write B
End Sub

Private Function GetFileName(path As String) As String
    GetFileName = Mid$(path, InStrRev(path, "\") + 1)
End Function

Private Function Base64ToFile(base64String As String, outPath As String) As Boolean
    On Error GoTo ErrH
    Dim xmlObj As Object, bytes() As Byte, stm As Object

    Set xmlObj = CreateObject("MSXML2.DOMDocument.6.0").createElement("b64")
    xmlObj.DataType = "bin.base64"
    xmlObj.Text = base64String
    bytes = xmlObj.NodeTypedValue

    Set stm = CreateObject("ADODB.Stream")
    With stm
        .Type = 1
        .Open
        .Write bytes
        .SaveToFile outPath, 2
        .Close
    End With

    Base64ToFile = True
    Exit Function
ErrH:
    Base64ToFile = False
End Function

Private Function GetJsonValue(json As String, key As String) As String
    Dim p As Long, q As Long, r As Long, tmp As String
    p = InStr(1, json, """" & key & """", vbTextCompare)
    If p = 0 Then Exit Function
    p = InStr(p, json, ":", vbTextCompare)
    If p = 0 Then Exit Function
    Do While Mid$(json, p + 1, 1) = " ": p = p + 1: Loop
    If Mid$(json, p + 1, 1) = """" Then
        q = InStr(p + 2, json, """")
        GetJsonValue = Mid$(json, p + 2, q - (p + 2))
    Else
        q = InStr(p + 1, json, ",")
        r = InStr(p + 1, json, "}")
        If q = 0 Or (r > 0 And r < q) Then q = r
        tmp = Trim$(Mid$(json, p + 1, q - (p + 1)))
        GetJsonValue = tmp
    End If
End Function


' =========================================
' 4) ALIGNMENT UTILITIES (same as before)
' =========================================
Private Function CleanText(ByVal s As String) As String
    Dim t As String
    t = Replace(s, ChrW(160), " ")
    t = Replace(t, vbTab, " ")
    t = Replace(t, vbCr, " ")
    t = Replace(t, vbLf, " ")
    t = Replace(t, Chr(11), " ")
    t = Replace(t, Chr(7), "")
    Do While InStr(t, "  ") > 0
        t = Replace(t, "  ", " ")
    Loop
    CleanText = Trim$(t)
End Function

Private Function ParaLen(ByVal s As String) As Long
    ParaLen = Len(Replace(Replace(s, " ", ""), vbTab, ""))
End Function

Private Function SumLen(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As Long
    Dim i As Long, n As Long
    For i = i1 To i2: n = n + ParaLen(arr(i)): Next
    SumLen = n
End Function

Private Function JoinRange(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As String
    Dim i As Long, t As String
    For i = i1 To i2
        If Len(arr(i)) > 0 Then
            If Len(t) > 0 Then t = t & vbCrLf & arr(i) Else t = arr(i)
        End If
    Next
    JoinRange = t
End Function

Private Function EndsWithAny(ByVal s As String, ByVal chars As String) As Boolean
    If Len(s) = 0 Then Exit Function
    EndsWithAny = InStr(1, chars, Right$(s, 1), vbBinaryCompare) > 0
End Function

Private Sub CollectParagraphs(doc As Document, ByRef texts() As String)
    Dim p As Paragraph, tmp As New Collection, s As String, i As Long
    For Each p In doc.Paragraphs
        s = CleanText(p.Range.Text)
        If Len(s) > 0 Then tmp.Add s
    Next
    If tmp.Count = 0 Then
        ReDim texts(1 To 1): texts(1) = ""
    Else
        ReDim texts(1 To tmp.Count)
        For i = 1 To tmp.Count: texts(i) = tmp(i): Next
    End If
End Sub

Private Sub DefragmentParas(ByRef arr() As String)
    If Not ENABLE_DEFRAG Then Exit Sub
    If UBound(arr) < 2 Then Exit Sub
    Dim outCol As New Collection, i As Long, buf As String, enough As Boolean
    For i = LBound(arr) To UBound(arr)
        If Len(buf) = 0 Then buf = arr(i) Else buf = buf & " " & arr(i)
        enough = (ParaLen(buf) >= DEFRAG_MIN_CHARS) Or EndsWithAny(buf, DEFRAG_SENT_ENDS)
        If enough Then outCol.Add Trim$(buf): buf = ""
    Next
    If Len(buf) > 0 Then outCol.Add Trim$(buf)
    ReDim arr(1 To outCol.Count)
    For i = 1 To outCol.Count: arr(i) = outCol(i): Next
End Sub

Private Function AlignCost(EN() As String, DE() As String, ei1 As Long, ei2 As Long, dj1 As Long, dj2 As Long, ratio As Double, penalty As Double) As Double
    Dim lenEN As Long: lenEN = SumLen(EN, ei1, ei2)
    Dim lenDE As Long: lenDE = SumLen(DE, dj1, dj2)
    Dim dev As Double: dev = Abs(lenDE - lenEN * ratio)
    AlignCost = dev ^ 0.9 + penalty
End Function

Private Sub UpdateCell(ByRef cost() As Double, ByRef backA() As AlignAction, ByRef backI() As Long, ByRef backJ() As Long, ni As Long, nj As Long, newCost As Double, action As AlignAction, pi As Long, pj As Long)
    If newCost < cost(ni, nj) Then
        cost(ni, nj) = newCost
        backA(ni, nj) = action
        backI(ni, nj) = pi
        backJ(ni, nj) = pj
    End If
End Sub


' =========================================
' 5) MAIN MACRO
' =========================================
Public Sub AlignTranslatedParagraphs_AutoPick()
    Dim enDoc As Document, deDoc As Document, outDoc As Document, tbl As Table
    Dim enDocx As String, deDocx As String
    Dim enPDF As String, dePDF As String

    Application.ScreenUpdating = False
    On Error GoTo ErrorHandler

    enPDF = BrowseForFile("Select the FIRST PDF (English)")
    If enPDF = "" Then GoTo Cleanup
    dePDF = BrowseForFile("Select the SECOND PDF (German)")
    If dePDF = "" Then GoTo Cleanup

    enDocx = ConvertPdfToWord_ConvertAPI(enPDF)
    If enDocx = "" Then GoTo Cleanup
    deDocx = ConvertPdfToWord_ConvertAPI(dePDF)
    If deDocx = "" Then GoTo Cleanup

    Set enDoc = Documents.Open(enDocx, ReadOnly:=True)
    Set deDoc = Documents.Open(deDocx, ReadOnly:=True)

    Dim EN() As String, DE() As String
    CollectParagraphs enDoc, EN
    CollectParagraphs deDoc, DE
    DefragmentParas EN
    DefragmentParas DE

    Dim sumEN As Long, sumDE As Long, i As Long
    For i = LBound(EN) To UBound(EN): sumEN = sumEN + ParaLen(EN(i)): Next
    For i = LBound(DE) To UBound(DE): sumDE = sumDE + ParaLen(DE(i)): Next
    Dim r As Double: If sumEN > 0 Then r = sumDE / sumEN Else r = 1#

    Dim n As Long, m As Long
    n = UBound(EN): m = UBound(DE)
    Dim cost() As Double, backA() As AlignAction, backI() As Long, backJ() As Long
    ReDim cost(0 To n, 0 To m)
    ReDim backA(0 To n, 0 To m)
    ReDim backI(0 To n, 0 To m)
    ReDim backJ(0 To n, 0 To m)

    Dim INF As Double: INF = 1E+30
    For i = 0 To n: For m = 0 To m: cost(i, m) = INF: Next m: Next i
    cost(0, 0) = 0

    Dim j As Long, c As Double
    For i = 0 To n
        For j = 0 To m
            If cost(i, j) < INF Then
                If i + 1 <= n And j + 1 <= m Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 1, r, 0)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 1, cost(i, j) + c, act_1x1, i, j
                End If
            End If
        Next j
    Next i

    enDoc.Close False: deDoc.Close False

    Set outDoc = Documents.Add
    Set tbl = outDoc.Tables.Add(Range:=outDoc.Range(0, 0), NumRows:=3, NumColumns:=3)
    tbl.Cell(1, 1).Range.Text = "English"
    tbl.Cell(1, 2).Range.Text = "German"
    tbl.Cell(1, 3).Range.Text = "Mapping"

    MsgBox "Alignment complete!", vbInformation

Cleanup:
    Application.ScreenUpdating = True
    On Error Resume Next
    If Len(enDocx) > 0 Then Kill enDocx
    If Len(deDocx) > 0 Then Kill deDocx
    Exit Sub

ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
    Resume Cleanup
End Sub