// src/processing/json_parser.py
import json
from pathlib import Path
from typing import List, Dict, Any

import config

ContentItem = Dict[str, Any]


# --- DELETED ---
# The entire _convert_table_to_markdown function (80+ lines) is gone.
# --- END DELETED ---


def process_document_json(doc_intelligence_data: Any) -> List[ContentItem]:
    # Allow passing a file path or a preloaded dict
    if isinstance(doc_intelligence_data, (str, Path)):
        with open(Path(doc_intelligence_data), 'r', encoding='utf-8') as f:
            doc_intelligence_data = json.load(f)

    try:
        analyze_result = doc_intelligence_data['analyzeResult']
        # 'content' is now a full Markdown string
        full_text_content = analyze_result['content']
        raw_paragraphs = analyze_result.get('paragraphs', [])
        pages = analyze_result.get('pages', [])
        raw_tables = analyze_result.get('tables', [])
    except KeyError as e:
        raise ValueError(f"Document Intelligence data is missing expected key: {e}") from e

    # --- Step 1: Identify all character offsets belonging to tables to avoid duplication ---
    table_offsets = set()
    for table in raw_tables:
        for span in table.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                table_offsets.add(i)

    # Identify all character offsets that are handwritten
    handwritten_offsets = set()
    if 'styles' in analyze_result:
        for style in analyze_result['styles']:
            if style.get('isHandwritten') and style.get('spans'):
                for span in style['spans']:
                    for i in range(span['offset'], span['offset'] + span['length']):
                        handwritten_offsets.add(i)

    # Create a quick lookup for page number by span offset
    page_lookup = {}
    for page in pages:
        for span in page.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                page_lookup[i] = page.get('pageNumber', 0)

    # --- Step 2: Extract all content, including tables, and sort by position ---
    all_content: List[ContentItem] = []

    # Process PARAGRAPHS
    for p in raw_paragraphs:
        role = p.get('role', 'paragraph')
        if role in config.IGNORED_ROLES or not p.get('spans'):
            continue

        offset = p['spans'][0]['offset']
        # If the paragraph is inside a table or is handwritten, SKIP it.
        if offset in table_offsets or offset in handwritten_offsets:
            continue

        length = p['spans'][0]['length']
        # This text is now Markdown-aware (e.g., includes #, *, etc.)
        text = full_text_content[offset : offset + length].strip()
        page_number = page_lookup.get(offset, 0)
        if text:
            all_content.append({'text': text, 'type': role, 'page': page_number, 'offset': offset})

    # --- MODIFIED ---
    # Process TABLES
    for table in raw_tables:
        if not table.get('spans'):
            continue
        offset = table['spans'][0]['offset']
        length = table['spans'][0]['length']
        page_number = page_lookup.get(offset, 0)
        
        # We no longer build the table manually.
        # We just extract the pre-formatted HTML <table> string 
        # from the main content.
        table_html = full_text_content[offset : offset + length].strip()
        
        if table_html:
            all_content.append({'text': table_html, 'type': 'table', 'page': page_number, 'offset': offset})
    # --- END MODIFIED ---

    # Sort all extracted content by its character offset to maintain document order
    all_content.sort(key=lambda x: x['offset'])

    # --- Step 3: Stitch broken paragraphs ---
    # (This logic remains UNCHANGED as it's still needed)
    final_content: List[ContentItem] = []
    stitched_text = ""
    current_page = 0
    current_type = "paragraph"

    for i, segment in enumerate(all_content):
        # If the current element is a table or a structural heading, finalize the previous stitched text.
        is_standalone = segment['type'] in config.STRUCTURAL_ROLES or segment['type'] == 'table'

        if is_standalone:
            if stitched_text:  # Finalize any pending paragraph
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = ""
            final_content.append(segment)  # Add the standalone item
            continue

        # This logic handles stitching of regular paragraphs
        if not stitched_text:  # Start a new paragraph
            stitched_text = segment['text']
            current_page = segment['page']
            current_type = segment['type']
        else:
            # If previous text ends with punctuation, start a new paragraph
            if stitched_text.endswith(('.', '!', '?')):
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = segment['text']
                current_page = segment['page']
                current_type = segment['type']
            else:  # Continue stitching the current paragraph
                stitched_text += f" {segment['text']}"

    # Add the last stitched paragraph if it exists
    if stitched_text:
        final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})

    return final_content








// src/clients/doc_intelligence_client.py
import os
import json
from datetime import datetime
from pathlib import Path

from azure.core.credentials import AzureKeyCredential
from azure.ai.documentintelligence import DocumentIntelligenceClient
# --- NEW ---
# Import the model for the output_content_format enum
from azure.ai.documentintelligence.models import ContentFormat 

import config

def analyze_pdf(pdf_bytes: bytes, original_filename: str) -> dict:
    endpoint = os.getenv("AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT")
    key = os.getenv("AZURE_DOCUMENT_INTELLIGENCE_KEY")

    if not endpoint or not key:
        raise ValueError(
            "Azure Document Intelligence credentials are not configured. "
            "Set AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT and AZURE_DOCUMENT_INTELLIGENCE_KEY in your .env file."
        )

    print(f"Connecting to Document Intelligence service for '{original_filename}'...")
    client = DocumentIntelligenceClient(endpoint=endpoint, credential=AzureKeyCredential(key))

    # --- MODIFIED ---
    # Request the "markdown" content format
    poller = client.begin_analyze_document(
        model_id="prebuilt-layout", 
        body=pdf_bytes, 
        content_type="application/pdf",
        output_content_format=ContentFormat.MARKDOWN  # <-- ADDED THIS LINE
    )
    # --- END MODIFIED ---
    
    result = poller.result()
    print("-> Analysis complete.")

    # --- Setup output paths ---
    output_dir = Path(config.OUTPUT_DIR)
    output_dir.mkdir(exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base_name = Path(original_filename).stem

    # --- NEW: Save raw Markdown output ---
    if result.content:
        output_md_filename = f"doc_intelligence_raw_{base_name}_{timestamp}.md"
        output_md_path = output_dir / output_md_filename
        try:
            with open(output_md_path, 'w', encoding='utf-8') as f:
                f.write(result.content)
            print(f"-> Saved raw Markdown output to '{output_md_path}'")
        except Exception as e:
            print(f"Warning: Could not save raw Markdown output. Reason: {e}")
    # --- END NEW ---

    # Robust serialization across SDK versions; wrap with expected top-level key
    try:
        ar_dict = result.as_dict()  # newer SDKs
    except AttributeError:
        try:
            ar_dict = result.to_dict()  # older SDKs
        except AttributeError:
            # Manual fallback
            ar_dict = {
                "content": getattr(result, "content", ""),
                "pages": [p.as_dict() if hasattr(p, "as_dict") else (p.to_dict() if hasattr(p, "to_dict") else {}) for p in getattr(result, "pages", [])],
                "paragraphs": [x.as_dict() if hasattr(x, "as_dict") else (x.to_dict() if hasattr(x, "to_dict") else {}) for x in getattr(result, "paragraphs", [])],
                "tables": [t.as_dict() if hasattr(t, "as_dict") else (t.to_dict() if hasattr(t, "to_dict") else {}) for t in getattr(result, "tables", [])],
                "styles": [s.as_dict() if hasattr(s, "as_dict") else (s.to_dict() if hasattr(s, "to_dict") else {}) for s in getattr(result, "styles", [])],
            }

    result_dict = {"analyzeResult": ar_dict}

    # Save JSON for reference
    output_filename = f"doc_intelligence_{base_name}_{timestamp}.json"
    output_path = output_dir / output_filename

    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(result_dict, f, ensure_ascii=False, indent=4)
        print(f"-> Saved Document Intelligence JSON to '{output_path}'")
    except Exception as e:
        print(f"Warning: Could not save JSON output for '{original_filename}'. Reason: {e}")

    return result_dict

