// test_1/src/alignment/semantic_aligner.py
from typing import List, Dict, Any
from pathlib import Path
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from openai import AzureOpenAI
from tqdm import tqdm
from scipy.optimize import linear_sum_assignment  # New import for Hungarian algorithm

import config
from src.reporting.excel_writer import save_calculation_report

# Type Aliases for clarity
ContentItem = Dict[str, Any]
AlignedPair = Dict[str, Any]

# A reusable client instance
_client = None

def _get_azure_client() -> AzureOpenAI:
    """Initializes and returns a reusable AzureOpenAI client."""
    global _client
    if _client is None:
        print("Initializing Azure OpenAI client...")
        if not all([config.AZURE_EMBEDDING_ENDPOINT, config.AZURE_EMBEDDING_API_KEY]):
            raise ValueError("Azure credentials (endpoint, key) are not set in the config/.env file.")

        _client = AzureOpenAI(
            api_version=config.AZURE_API_VERSION,
            azure_endpoint=config.AZURE_EMBEDDING_ENDPOINT,
            api_key=config.AZURE_EMBEDDING_API_KEY,
        )
    return _client

def _get_embeddings_in_batches(
    texts: List[str], 
    content_items: List[ContentItem],  # New parameter
    client: AzureOpenAI, 
    batch_size: int = 16,
    context_window: int = 0  # New parameter
) -> np.ndarray:
    """
    Generates embeddings by sending texts to the Azure API in batches.
    Optionally includes context from surrounding segments.
    """
    # Generate texts with context if context_window > 0
    if context_window > 0:
        texts_with_context = []
        for i, text in enumerate(texts):
            # Get preceding context
            pre_context = ""
            for j in range(max(0, i - context_window), i):
                pre_context += f"{content_items[j]['text']} "

            # Get following context
            post_context = ""
            for j in range(i + 1, min(len(texts), i + context_window + 1)):
                post_context += f" {content_items[j]['text']}"

            # Include content type and page number for additional context
            content_type = content_items[i]['type']
            page_num = content_items[i]['page']

            # Create context-enhanced text
            if pre_context or post_context:
                context_text = f"{pre_context}[SEP]{text}[SEP]{post_context} [TYPE:{content_type}] [PAGE:{page_num}]"
            else:
                context_text = f"{text} [TYPE:{content_type}] [PAGE:{page_num}]"

            texts_with_context.append(context_text)

        # Use the context-enhanced texts
        texts_to_embed = texts_with_context
    else:
        # Use original texts
        texts_to_embed = texts

    # Generate embeddings in batches
    all_embeddings = []
    for i in tqdm(range(0, len(texts_to_embed), batch_size), desc="Generating Embeddings"):
        batch = texts_to_embed[i:i + batch_size]
        try:
            response = client.embeddings.create(
                input=batch,
                model=config.AZURE_EMBEDDING_DEPLOYMENT_NAME
            )
            batch_embeddings = [item.embedding for item in response.data]
            all_embeddings.extend(batch_embeddings)
        except Exception as e:
            print(f"An error occurred while processing a batch: {e}")
            # Add placeholder embeddings for the failed batch to avoid size mismatch
            all_embeddings.extend([[0.0] * 3072] * len(batch))  # text-embedding-3-large has 3072 dimensions

    return np.array(all_embeddings)

def _calculate_type_matrix(eng_content: List[ContentItem], ger_content: List[ContentItem]) -> np.ndarray:
    num_eng = len(eng_content)
    num_ger = len(ger_content)
    type_matrix = np.zeros((num_eng, num_ger))

    for i in range(num_eng):
        for j in range(num_ger):
            if eng_content[i]['type'] == ger_content[j]['type']:
                type_matrix[i, j] = config.TYPE_MATCH_BONUS
            else:
                type_matrix[i, j] = config.TYPE_MISMATCH_PENALTY
    return type_matrix

def _calculate_proximity_matrix(num_eng: int, num_ger: int) -> np.ndarray:
    proximity_matrix = np.zeros((num_eng, num_ger))
    for i in range(num_eng):
        for j in range(num_ger):
            norm_pos_eng = i / num_eng if num_eng > 0 else 0
            norm_pos_ger = j / num_ger if num_ger > 0 else 0
            proximity_matrix[i, j] = 1.0 - abs(norm_pos_eng - norm_pos_ger)
    return proximity_matrix

def align_content(
    english_content: List[ContentItem],
    german_content: List[ContentItem],
    algorithm: str = "mutual",  # New parameter
    context_window: int = 0,    # New parameter
    generate_debug_report: bool = False,
    debug_report_path: Path = None
) -> List[AlignedPair]:
    """
    Aligns content between English and German documents.

    Args:
        english_content: List of English content items
        german_content: List of German content items
        algorithm: Matching algorithm to use ("mutual" or "hungarian")
        context_window: Size of context window (0 for no context)
        generate_debug_report: Whether to generate a detailed calculation report
        debug_report_path: Path to save the debug report

    Returns:
        List of aligned pairs
    """
    if not english_content or not german_content:
        return []

    client = _get_azure_client()
    num_eng, num_ger = len(english_content), len(german_content)

    eng_texts = [item['text'] for item in english_content]
    ger_texts = [item['text'] for item in german_content]

    # Generate embeddings using the updated function with context support
    english_embeddings = _get_embeddings_in_batches(
        eng_texts, 
        english_content,  # Pass content items for context
        client,
        context_window=context_window
    )
    german_embeddings = _get_embeddings_in_batches(
        ger_texts, 
        german_content,  # Pass content items for context
        client,
        context_window=context_window
    )

    print("Calculating score matrices (semantic, type, proximity)...")
    semantic_matrix = cosine_similarity(english_embeddings, german_embeddings)
    type_matrix = _calculate_type_matrix(english_content, german_content)
    proximity_matrix = _calculate_proximity_matrix(num_eng, num_ger)

    blended_matrix = (
        (config.W_SEMANTIC * semantic_matrix) +
        (config.W_TYPE * type_matrix) +
        (config.W_PROXIMITY * proximity_matrix)
    )

    if generate_debug_report and debug_report_path:
        print("Generating detailed calculation report for debugging...")
        save_calculation_report(
            english_content=english_content,
            german_content=german_content,
            blended_matrix=blended_matrix,
            semantic_matrix=semantic_matrix,
            type_matrix=type_matrix,
            proximity_matrix=proximity_matrix,
            filepath=debug_report_path
        )

    aligned_pairs: List[AlignedPair] = []
    used_german_indices = set()

    # Choose matching algorithm based on parameter
    if algorithm == "hungarian":
        print("Finding optimal global alignment using Hungarian algorithm...")
        # Hungarian algorithm minimizes cost, so we negate the similarity scores
        cost_matrix = -blended_matrix.copy()

        # Find optimal assignment
        row_indices, col_indices = linear_sum_assignment(cost_matrix)

        # Process the matches found by the Hungarian algorithm
        for eng_idx, ger_idx in zip(row_indices, col_indices):
            score = blended_matrix[eng_idx, ger_idx]

            # Only include matches that meet the threshold
            if score >= config.SIMILARITY_THRESHOLD:
                semantic_score = semantic_matrix[eng_idx, ger_idx]
                aligned_pairs.append({
                    "english": english_content[eng_idx],
                    "german": german_content[ger_idx],
                    "similarity": float(semantic_score)  # Cast to float for JSON serialization
                })
                used_german_indices.add(ger_idx)
    else:
        print("Finding best matches based on mutual best match algorithm...")
        best_ger_matches = np.argmax(blended_matrix, axis=1)
        best_eng_matches = np.argmax(blended_matrix, axis=0)

        for eng_idx, ger_idx in enumerate(best_ger_matches):
            is_mutual_best_match = (best_eng_matches[ger_idx] == eng_idx)
            score = blended_matrix[eng_idx, ger_idx]

            if is_mutual_best_match and score >= config.SIMILARITY_THRESHOLD:
                semantic_score = semantic_matrix[eng_idx, ger_idx]
                aligned_pairs.append({
                    "english": english_content[eng_idx],
                    "german": german_content[ger_idx],
                    "similarity": float(semantic_score)  # Cast to float for JSON serialization
                })
                used_german_indices.add(ger_idx)

    # Add unmatched English content
    matched_english_ids = {id(pair['english']) for pair in aligned_pairs if pair.get('english')}
    for item in english_content:
        if id(item) not in matched_english_ids:
            aligned_pairs.append({"english": item, "german": None, "similarity": 0.0})

    # Add unmatched German content
    for idx, item in enumerate(german_content):
        if idx not in used_german_indices:
             aligned_pairs.append({"english": None, "german": item, "similarity": 0.0})

    # Sort by English page number
    aligned_pairs.sort(key=lambda x: x['english']['page'] if x.get('english') else float('inf'))

    return aligned_pairs

// test_1/src/reporting/markdown_writer.py
from pathlib import Path
from typing import List, Dict, Any

ContentItem = Dict[str, Any]

def save_to_markdown(content: List[ContentItem], filepath: Path) -> None:
    with open(filepath, 'w', encoding='utf-8') as f:
        for item in content:
            if item['type'] in {'title', 'sectionHeading', 'subheading'}:
                f.write(f"## {item['text']}\n\n")
            else:
                f.write(f"{item['text']}\n\n")

// test_1/src/reporting/excel_writer.py
# document_aligner/src/reporting/excel_writer.py

from pathlib import Path
from typing import List, Dict, Any
import pandas as pd
import numpy as np

import config

# (Type aliases and the first two functions, save_alignment_report and save_evaluation_report, are unchanged)
AlignedPair = Dict[str, Any]
EvaluationFinding = Dict[str, Any]
ContentItem = Dict[str, Any]

def save_alignment_report(aligned_data: List[AlignedPair], filepath: Path) -> None:
    """Saves the document alignment data to an Excel file."""
    if not aligned_data:
        print("Warning: No aligned data to save to Excel.")
        return
    report_data = []
    for pair in aligned_data:
        eng_item = pair.get('english')
        ger_item = pair.get('german')
        report_data.append({
            "English": eng_item.get('text', '') if eng_item else "--- OMITTED ---",
            "German": ger_item.get('text', '') if ger_item else "--- ADDED ---",
            "Similarity": f"{pair.get('similarity', 0.0):.4f}",
            "Type": (eng_item.get('type') if eng_item else ger_item.get('type', 'N/A')),
            "English Page": (eng_item.get('page') if eng_item else 'N/A'),
            "German Page": (ger_item.get('page') if ger_item else 'N/A')
        })
    df = pd.DataFrame(report_data)
    try:
        df.to_excel(filepath, index=False, engine='openpyxl')
    except Exception as e:
        print(f"Error: Could not write alignment report to '{filepath}'. Reason: {e}")

def save_evaluation_report(evaluation_results: List[EvaluationFinding], filepath: Path) -> None:
    """Saves the AI evaluation findings to a separate Excel report."""
    if not evaluation_results:
        print("No evaluation findings to save.")
        return
    evaluation_results.sort(key=lambda x: x.get('page', 0))
    df = pd.DataFrame(evaluation_results)
    desired_columns = [
        "page", "type", "suggestion", "english_text", "german_text", 
        "original_phrase", "translated_phrase"
    ]
    final_columns = [col for col in desired_columns if col in df.columns]
    df = df[final_columns]
    try:
        df.to_excel(filepath, index=False, sheet_name='Evaluation_Findings')
    except Exception as e:
        print(f"Error: Could not write evaluation report to '{filepath}'. Reason: {e}")

def save_calculation_report(
    english_content: List[ContentItem],
    german_content: List[ContentItem],
    blended_matrix: np.ndarray,
    semantic_matrix: np.ndarray,
    type_matrix: np.ndarray,
    proximity_matrix: np.ndarray,
    filepath: Path
):
    """
    Saves a highly detailed, two-sheet Excel report showing all alignment score calculations.
    """
    try:
        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
            # --- Process English Sheet ---
            eng_report_data = []
            best_ger_indices = np.argmax(blended_matrix, axis=1)

            for i, item in enumerate(english_content):
                best_match_idx = best_ger_indices[i]
                best_match_item = german_content[best_match_idx]

                raw_semantic = semantic_matrix[i, best_match_idx]
                raw_type = type_matrix[i, best_match_idx]
                raw_proximity = proximity_matrix[i, best_match_idx]

                eng_report_data.append({
                    "Text": item['text'],
                    "Type": item['type'],
                    "Page No": item['page'],

                    # --- Detailed Semantic Columns ---
                    "Raw Semantic": f"{raw_semantic:.4f}",
                    "Semantic Calculation": f"{raw_semantic:.4f} x {config.W_SEMANTIC}",
                    "Weighted Semantic": f"{raw_semantic * config.W_SEMANTIC:.4f}",

                    # --- Detailed Type Columns ---
                    "Raw Type": f"{raw_type:.1f}",
                    "Type Calculation": f"{raw_type:.1f} x {config.W_TYPE}",
                    "Weighted Type": f"{raw_type * config.W_TYPE:.4f}",

                    # --- Detailed Proximity Columns ---
                    "Raw Proximity": f"{raw_proximity:.4f}",
                    "Proximity Calculation": f"{raw_proximity:.4f} x {config.W_PROXIMITY}",
                    "Weighted Proximity": f"{raw_proximity * config.W_PROXIMITY:.4f}",

                    "Total Score": f"{blended_matrix[i, best_match_idx]:.4f}",
                    "Best Match (German)": best_match_item['text'],
                    "Best Match Type": best_match_item['type'],  # New column
                    "Best Match Page": best_match_item['page']   # New column
                })

            df_eng = pd.DataFrame(eng_report_data)
            df_eng.to_excel(writer, sheet_name='English Calculations', index=False)

            # --- Process German Sheet ---
            ger_report_data = []
            best_eng_indices = np.argmax(blended_matrix, axis=0)

            for j, item in enumerate(german_content):
                best_match_idx = best_eng_indices[j]
                best_match_item = english_content[best_match_idx]

                raw_semantic = semantic_matrix[best_match_idx, j]
                raw_type = type_matrix[best_match_idx, j]
                raw_proximity = proximity_matrix[best_match_idx, j]

                ger_report_data.append({
                    "Text": item['text'],
                    "Type": item['type'],
                    "Page No": item['page'],

                    "Raw Semantic": f"{raw_semantic:.4f}",
                    "Semantic Calculation": f"{raw_semantic:.4f} x {config.W_SEMANTIC}",
                    "Weighted Semantic": f"{raw_semantic * config.W_SEMANTIC:.4f}",

                    "Raw Type": f"{raw_type:.1f}",
                    "Type Calculation": f"{raw_type:.1f} x {config.W_TYPE}",
                    "Weighted Type": f"{raw_type * config.W_TYPE:.4f}",

                    "Raw Proximity": f"{raw_proximity:.4f}",
                    "Proximity Calculation": f"{raw_proximity:.4f} x {config.W_PROXIMITY}",
                    "Weighted Proximity": f"{raw_proximity * config.W_PROXIMITY:.4f}",

                    "Total Score": f"{blended_matrix[best_match_idx, j]:.4f}",
                    "Best Match (English)": best_match_item['text'],
                    "Best Match Type": best_match_item['type'],  # New column
                    "Best Match Page": best_match_item['page']   # New column
                })

            df_ger = pd.DataFrame(ger_report_data)
            df_ger.to_excel(writer, sheet_name='German Calculations', index=False)

    except Exception as e:
        print(f"Error: Could not write debug calculation report to '{filepath}'. Reason: {e}")

// test_1/src/processing/json_parser.py
# document_aligner/src/processing/json_parser.py

import json
from pathlib import Path
from typing import List, Dict, Any

import config

# A type alias for our structured content for clarity
ContentItem = Dict[str, Any]

def _convert_table_to_markdown(table_obj: Dict) -> str:
    """Converts an Azure table object into a Markdown string."""
    markdown_str = ""
    if not table_obj.get('cells'):
        return ""

    # Create header
    header_cells = [cell for cell in table_obj['cells'] if cell.get('kind') == 'columnHeader']
    if header_cells:
        header_cells.sort(key=lambda x: x['columnIndex'])
        # Handle cells that might span multiple columns
        header_content = []
        for cell in header_cells:
            content = cell.get('content', '').strip()
            col_span = cell.get('columnSpan', 1)
            header_content.extend([content] * col_span)
        
        header_row = "| " + " | ".join(header_content) + " |"
        separator_row = "| " + " | ".join(["---"] * len(header_content)) + " |"
        markdown_str += header_row + "\n" + separator_row + "\n"

    # Create body rows
    body_cells = [cell for cell in table_obj['cells'] if cell.get('kind') is None]
    
    rows = {}
    for cell in body_cells:
        row_idx = cell.get('rowIndex', 0)
        if row_idx not in rows:
            rows[row_idx] = []
        rows[row_idx].append(cell)

    for row_idx in sorted(rows.keys()):
        row_cells = sorted(rows[row_idx], key=lambda x: x.get('columnIndex', 0))
        row_str = "| " + " | ".join([cell.get('content', '').strip() for cell in row_cells]) + " |"
        markdown_str += row_str + "\n"
        
    return markdown_str.strip()


def process_document_json(filepath: Path) -> List[ContentItem]:
    """
    Reads and processes an Azure Document Intelligence JSON file,
    now with dedicated handling for tables.
    """
    if not filepath.exists():
        raise FileNotFoundError(f"The file '{filepath}' was not found.")

    with open(filepath, 'r', encoding='utf-8') as f:
        data = json.load(f)

    try:
        analyze_result = data['analyzeResult']
        full_text_content = analyze_result['content']
        raw_paragraphs = analyze_result.get('paragraphs', [])
        pages = analyze_result.get('pages', [])
        raw_tables = analyze_result.get('tables', [])
    except KeyError as e:
        raise ValueError(f"JSON file '{filepath}' is missing expected key: {e}") from e
    
    # --- Step 1: Identify all character offsets belonging to tables to avoid duplication ---
    table_offsets = set()
    for table in raw_tables:
        for span in table.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                table_offsets.add(i)
    
    # Identify all character offsets that are handwritten
    handwritten_offsets = set()
    if 'styles' in analyze_result:
        for style in analyze_result['styles']:
            if style.get('isHandwritten') and style.get('spans'):
                for span in style['spans']:
                    for i in range(span['offset'], span['offset'] + span['length']):
                        handwritten_offsets.add(i)
    
    # Create a quick lookup for page number by span offset
    page_lookup = {}
    for page in pages:
        for span in page.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                page_lookup[i] = page.get('pageNumber', 0)

    # --- Step 2: Extract all content, including tables, and sort by position ---
    all_content: List[ContentItem] = []

    # Process PARAGRAPHS
    for p in raw_paragraphs:
        role = p.get('role', 'paragraph')
        if role in config.IGNORED_ROLES or not p.get('spans'):
            continue
        
        offset = p['spans'][0]['offset']
        # If the paragraph is inside a table or is handwritten, SKIP it.
        if offset in table_offsets or offset in handwritten_offsets:
            continue
            
        length = p['spans'][0]['length']
        text = full_text_content[offset : offset + length].strip()
        page_number = page_lookup.get(offset, 0)
        if text:
            all_content.append({'text': text, 'type': role, 'page': page_number, 'offset': offset})
            
    # Process TABLES
    for table in raw_tables:
        if not table.get('spans'):
            continue
        offset = table['spans'][0]['offset']
        page_number = page_lookup.get(offset, 0)
        markdown_table = _convert_table_to_markdown(table)
        if markdown_table:
            all_content.append({'text': markdown_table, 'type': 'table', 'page': page_number, 'offset': offset})

    # Sort all extracted content by its character offset to maintain document order
    all_content.sort(key=lambda x: x['offset'])

    # --- Step 3: Stitch broken paragraphs ---
    final_content: List[ContentItem] = []
    stitched_text = ""
    current_page = 0
    current_type = "paragraph"

    for i, segment in enumerate(all_content):
        # If the current element is a table or a structural heading, finalize the previous stitched text.
        is_standalone = segment['type'] in config.STRUCTURAL_ROLES or segment['type'] == 'table'

        if is_standalone:
            if stitched_text: # Finalize any pending paragraph
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = ""
            final_content.append(segment) # Add the standalone item
            continue

        # This logic handles stitching of regular paragraphs
        if not stitched_text: # Start a new paragraph
            stitched_text = segment['text']
            current_page = segment['page']
            current_type = segment['type']
        else:
            # If previous text ends with punctuation, start a new paragraph
            if stitched_text.endswith(('.', '!', '?', ':', '•')):
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = segment['text']
                current_page = segment['page']
                current_type = segment['type']
            else: # Continue stitching the current paragraph
                stitched_text += f" {segment['text']}"

    # Add the last stitched paragraph if it exists
    if stitched_text:
        final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
        
    return final_content

// test_1/src/evaluation/pipeline.py
# src/evaluation/pipeline.py
import json
from typing import List, Dict, Any, Optional
from tqdm import tqdm

from src.evaluation.evaluators import evaluate_translation_pair, check_context_mismatch
from src.clients.azure_client import chat

__all__ = ["run_evaluation_pipeline"]

AlignedPair = Dict[str, Any]
EvaluationFinding = Dict[str, Any]

def _agent2_validate_finding(
    eng_text: str,
    ger_text: str,
    error_type: str,
    explanation: str,
    model_name: Optional[str] = None,
):
    """
    Second-stage reviewer.  Confirms only truly fatal errors and rejects
    false positives.
    """
    prompt = f"""
## ROLE
**Senior Quality Reviewer** – you are the final gatekeeper of EN→DE
translation findings.

## TASK
Decide whether the finding delivered by Agent-1 must be *Confirmed* or
*Rejected*.

## INSTRUCTIONS
1. Eligible error_type values are **exactly**:
   • "Mistranslation"  
   • "Omission"

2. Confirm only when the evidence is unmistakable:
   • Mistranslation
       – number mismatch (digit or word)  
       – polarity flip / opposite meaning  
       – actor/role inversion  
   • Omission
       – English states an explicit count (“two”, “three”, “both” …) **or**
         lists concrete items, and at least one item is *truly* missing in
         German (not conveyed by paraphrase).

3. Reject when:
   • Difference is stylistic or synonymous.  
   • Proper names / document titles are rendered with an accepted German
     equivalent (e.g. “Nichtfinanzielle Erklärung”).  
   • Alleged omission is actually present via paraphrase.  

## OUTPUT ‑ JSON ONLY
json {{ "verdict" : "Confirm" | "Reject", "reasoning": "" }}

## MATERIAL TO REVIEW
English text:
\"\"\"{eng_text}\"\"\"

German text:
\"\"\"{ger_text}\"\"\"

Agent-1 proposed:
  error_type : {error_type}
  explanation: {explanation}

## YOUR RESPONSE
Return the JSON object only – no extra text.
"""
    try:
        content = chat(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            model=model_name,
        )
        j0, j1 = content.find("{"), content.rfind("}") + 1
        verdict_json = json.loads(content[j0:j1])
        is_confirmed = verdict_json.get("verdict", "").lower() == "confirm"
        reasoning = verdict_json.get("reasoning", "")
        return is_confirmed, reasoning, content.strip()
    except (ValueError, json.JSONDecodeError) as exc:
        print(f"  - Agent-2 JSON parse error: {exc}")
        return False, f"System error: {exc}", "{}"
    except Exception as exc:
        print(f"  - Agent-2 unexpected error: {exc}")
        return False, "System error (non-parsing issue)", "{}"

def run_evaluation_pipeline(aligned_pairs: List[AlignedPair]) -> List[EvaluationFinding]:
    findings = []

    for pair in tqdm(aligned_pairs, desc="Evaluating Pairs"):
        eng_elem = pair.get('english')
        ger_elem = pair.get('german')

        if eng_elem and not ger_elem:
            findings.append({
                "type": f"Omission",
                "english_text": eng_elem['text'],
                "german_text": "---",
                "suggestion": "This content from the English document is missing in the German document.",
                "page": eng_elem['page']
            })
            continue

        if not eng_elem and ger_elem:
            findings.append({
                "type": f"Addition",
                "english_text": "---",
                "german_text": ger_elem['text'],
                "suggestion": "This content from the German document does not appear to have a source in the English document.",
                "page": ger_elem['page']
            })
            continue

        if eng_elem and ger_elem:
            eng_text = eng_elem['text']
            ger_text = ger_elem['text']

            # Agent 1
            finding = evaluate_translation_pair(eng_text, ger_text)
            error_type = finding.get("error_type", "None")

            if error_type not in ["None", "System Error"]:
                # Agent 2
                is_confirmed, reasoning, _ = _agent2_validate_finding(
                    eng_text, ger_text, error_type, finding.get("explanation")
                )

                if is_confirmed:
                    findings.append({
                        "type": error_type,
                        "english_text": eng_text,
                        "german_text": ger_text,
                        "suggestion": finding.get("suggestion"),
                        "page": eng_elem.get('page'),
                        "original_phrase": finding.get("original_phrase"),
                        "translated_phrase": finding.get("translated_phrase")
                    })
                else: # Agent 2 rejected, run Agent 3
                    context_result = check_context_mismatch(eng_text, ger_text)
                    context_match_verdict = context_result.get('context_match', 'Error')
                    if context_match_verdict.lower() == "no":
                        findings.append({
                            "type": "Context Mismatch",
                            "english_text": eng_text,
                            "german_text": ger_text,
                            "suggestion": context_result.get("explanation"),
                            "page": eng_elem.get('page')
                        })

    return findings

// test_1/src/evaluation/evaluators.py
# src/evaluation/evaluators.py
import json
from src.clients.azure_client import chat  

def evaluate_translation_pair(eng_text: str, ger_text: str, model_name=None):
    prompt = f"""
## ROLE
You are the Primary Translation Auditor for EN→DE corporate reports.

## TASK
Identify only the two fatal error categories below and output ONE JSON object.

## ERROR TYPES YOU MAY REPORT
1. Mistranslation
   • Wrong numeric value (digits, words, units, decimals, percentages)
   • Polarity flip / negation error (e.g., required ↔ not required)
   • Change of actor or agency (who did/decided/informed whom)

2. Omission
   The English text states a concrete count (“two”, “three”, “both”, “either”) or lists specific items, and at least one required element is missing in German.

Do not flag: stylistic differences, safe synonyms, acceptable German report titles (“Nichtfinanzielle Erklärung”, “Erklärung zur Unternehmensführung” etc.), benign reordering, or tense/voice changes that preserve actor and meaning.

If no fatal error is found, return error_type "None".

If multiple fatal errors exist, choose the most impactful; if tied, prefer "Mistranslation".

## JSON OUTPUT SCHEMA
json {{ "error_type" : "Mistranslation" | "Omission" | "None", "original_phrase" : "", "translated_phrase": "", "explanation" : "<≤40 words>", "suggestion" : "" }}

## POSITIVE EXAMPLES
1 · Mistranslation (number)
EN “Revenue increased by 2.3 million.”
DE “Der Umsatz stieg um 2,8 Millionen.”
→ error_type “Mistranslation”, original “2.3 million”, translated “2,8 Millionen”

2 · Mistranslation (polarity)
EN “The audit is not required.”
DE “Die Prüfung ist erforderlich.”
→ error_type “Mistranslation”, original “not required”, translated “erforderlich”

3 · Mistranslation (actor/agency)
EN “The company was notified by the regulator.”
DE “Das Unternehmen informierte die Aufsichtsbehörde.”
→ error_type “Mistranslation”, original “was notified by the regulator”, translated “informierte die Aufsichtsbehörde”

4 · Omission (enumeration/count)
EN “Both measures will apply: cost cap and hiring freeze.”
DE “Es gilt die Einstellungsstop.”
→ error_type “Omission”, original “cost cap”, translated “”

5 · None (acceptable variation)
EN “The report is comprehensive.”
DE “Der Bericht ist umfassend.”
→ error_type “None”

## TEXTS TO AUDIT
<Original English>
{eng_text}
</Original English>

<German Translation>
{ger_text}
</German Translation>

## YOUR RESPONSE
Return the JSON object only—no extra text, no markdown.

## NOTES
- Compare all numbers, signs, and units (%, bps, million/Mio., billion/Mrd.).
- Treat passive/active voice as fine unless the responsible actor changes.
- For omissions, ensure every counted or listed element appears in German.
- Keep “explanation” concise; “suggestion” should minimally correct the German (or note the missing item).
"""
    try:
        content = chat(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            model=model_name,
        ).strip()

        j0, j1 = content.find("{"), content.rfind("}") + 1
        if j0 != -1 and j1 != -1:
            return json.loads(content[j0:j1])
        return {"error_type": "System Error",
                "explanation": "No JSON object in LLM reply."}
    except Exception as exc:
        print(f"evaluate_translation_pair → {exc}")
        return {"error_type": "System Error", "explanation": str(exc)}

def check_context_mismatch(eng_text: str, ger_text: str, model_name: str = None):
    prompt = f"""
ROLE: Narrative-Integrity Analyst

Goal: Decide if the German text tells a **different story** from the
English.  “Different” means a change in
• WHO does WHAT to WHOM
• factual outcome or direction of action
• polarity (e.g. “comprehensive” ↔ “unvollständig”)

Ignore style, word order, or minor re-phrasing.

Respond with JSON:

{{
  "context_match": "Yes" | "No",
  "explanation":  "<one concise sentence>"
}}

Examples
--------
1) Role reversal (should be No)
EN  Further, the committee *was informed* by the Board …
DE  Darüber hinaus *leitete der Ausschuss eine Untersuchung ein* …
→ roles flipped ⇒ "No"

2) Identical meaning (Yes)
EN  Declaration of Conformity with the German Corporate Governance Code
DE  Entsprechenserklärung zum Deutschen Corporate Governance Kodex
→ "Yes"

Analyse the following text pair and respond with the JSON only.

<Original_English>
{eng_text}
</Original_English>

<German_Translation>
{ger_text}
</German_Translation>
"""
    try:
        content = chat(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            model=model_name,
        ).strip()

        j0, j1 = content.find("{"), content.rfind("}") + 1
        return json.loads(content[j0:j1])
    except Exception as exc:
        return {"context_match": "Error", "explanation": str(exc)}

// test_1/src/clients/azure_client.py
import os
from typing import List, Dict, Any, Optional
from openai import AzureOpenAI
from dotenv import load_dotenv
load_dotenv()

_chat_client: Optional[AzureOpenAI] = None
_embedding_client: Optional[AzureOpenAI] = None

_cfg = {
    "chat_endpoint": None,
    "chat_api_key": None,
    "chat_api_version": None,
    "chat_deployment": None,
    "embedding_endpoint": None,
    "embedding_api_key": None,
    "embedding_api_version": None,
    "embedding_deployment": None,
}

def _load_env():
    # Chat configuration
    _cfg["chat_endpoint"] = os.getenv("AZURE_OPENAI_ENDPOINT")
    _cfg["chat_api_key"] = os.getenv("AZURE_OPENAI_API_KEY")
    _cfg["chat_api_version"] = os.getenv("AZURE_OPENAI_API_VERSION", "2024-02-01")
    _cfg["chat_deployment"] = os.getenv("AZURE_OPENAI_DEPLOYMENT")

    # Embedding configuration
    _cfg["embedding_endpoint"] = os.getenv("AZURE_EMBEDDING_ENDPOINT")
    _cfg["embedding_api_key"] = os.getenv("AZURE_EMBEDDING_API_KEY")
    _cfg["embedding_api_version"] = os.getenv("AZURE_API_VERSION", "2024-02-01")
    _cfg["embedding_deployment"] = os.getenv("AZURE_EMBEDDING_DEPLOYMENT_NAME")

def _get_chat_client() -> AzureOpenAI:
    global _chat_client
    if _chat_client is not None:
        return _chat_client

    _load_env()
    if not _cfg["chat_endpoint"] or not _cfg["chat_api_key"] or not _cfg["chat_deployment"]:
        raise RuntimeError(
            "Azure OpenAI chat client is not configured. "
            "Set AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_API_KEY, and AZURE_OPENAI_DEPLOYMENT in your .env file."
        )

    _chat_client = AzureOpenAI(
        azure_endpoint=_cfg["chat_endpoint"],
        api_key=_cfg["chat_api_key"],
        api_version=_cfg["chat_api_version"],
    )
    return _chat_client

def _get_embedding_client() -> AzureOpenAI:
    global _embedding_client
    if _embedding_client is not None:
        return _embedding_client

    _load_env()
    if not _cfg["embedding_endpoint"] or not _cfg["embedding_api_key"] or not _cfg["embedding_deployment"]:
        raise RuntimeError(
            "Azure OpenAI embedding client is not configured. "
            "Set AZURE_EMBEDDING_ENDPOINT, AZURE_EMBEDDING_API_KEY, and AZURE_EMBEDDING_DEPLOYMENT_NAME in your .env file."
        )

    _embedding_client = AzureOpenAI(
        azure_endpoint=_cfg["embedding_endpoint"],
        api_key=_cfg["embedding_api_key"],
        api_version=_cfg["embedding_api_version"] or _cfg["chat_api_version"],
    )
    return _embedding_client

def chat(messages: List[Dict[str, Any]], temperature: float = 0.1, model: Optional[str] = None) -> str:
    client = _get_chat_client()
    deployment = model or _cfg["chat_deployment"]

    resp = client.chat.completions.create(
        model=deployment,
        messages=messages,
        temperature=temperature,
    )
    return resp.choices[0].message.content or ""

def get_embeddings(texts: List[str], model: Optional[str]=None) -> List[List[float]]:
    client = _get_embedding_client()
    deployment = model or _cfg['embedding_deployment']

    if not deployment:
        raise ValueError("No embedding deployment specified. Please set AZURE_EMBEDDING_DEPLOYMENT_NAME in your .env file.")

    response = client.embeddings.create(
        input=texts,
        model=deployment
    )
    return [item.embedding for item in response.data]

// test_1/config.py
import os
from dotenv import load_dotenv

load_dotenv()

AZURE_EMBEDDING_ENDPOINT = os.getenv("AZURE_EMBEDDING_ENDPOINT")
AZURE_EMBEDDING_API_KEY = os.getenv("AZURE_EMBEDDING_API_KEY")
AZURE_EMBEDDING_DEPLOYMENT_NAME = os.getenv("AZURE_EMBEDDING_DEPLOYMENT_NAME")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-02-01")

IGNORED_ROLES = {'pageHeader', 'pageFooter', 'pageNumber'}
STRUCTURAL_ROLES = {'title', 'sectionHeading'}

W_SEMANTIC = 0.90  # Weight for semantic similarity (cosine score)
W_TYPE = 0.05      # Weight for matching content types (e.g., table vs. table)
W_PROXIMITY = 0.05 # Weight for relative position in the document

TYPE_MATCH_BONUS = 0.1
TYPE_MISMATCH_PENALTY = -0.2

# The minimum blended score for a pair to be considered a match
SIMILARITY_THRESHOLD = 0.7

INPUT_DIR: str = "input"
OUTPUT_DIR: str = "output"

// test_1/main.py
import argparse
import time
from pathlib import Path
import pandas as pd
from typing import List, Dict, Any

from dotenv import load_dotenv
load_dotenv()

import config
from src.processing.json_parser import process_document_json
from src.alignment.semantic_aligner import align_content, ContentItem  # Import ContentItem from here
from src.reporting.markdown_writer import save_to_markdown
from src.reporting.excel_writer import save_alignment_report, save_evaluation_report, save_calculation_report
from src.evaluation.pipeline import run_evaluation_pipeline

def main():
    parser = argparse.ArgumentParser(
        description="Aligns and optionally evaluates content from two Azure Document Intelligence JSON files."
    )
    parser.add_argument("english_json", type=str, help="Path to the English JSON file.")
    parser.add_argument("german_json", type=str, help="Path to the German JSON file.")
    parser.add_argument(
        "-o", "--output", type=str, help="Path for the output alignment Excel file.",
        default=None
    )
    parser.add_argument(
        "--evaluate", action="store_true",
        help="Run the AI evaluation pipeline after alignment."
    )
    parser.add_argument(
        "--debug-report", action="store_true",
        help="Generate a detailed Excel report showing the score calculations for debugging."
    )
    # New arguments for alignment options
    parser.add_argument(
        "--algorithm", type=str, choices=["mutual", "hungarian"], default="mutual",
        help="Alignment algorithm to use: mutual best match or Hungarian algorithm."
    )
    parser.add_argument(
        "--context-window", type=int, default=0,
        help="Size of context window (0 for no context, 1+ for context-aware embeddings)."
    )
    parser.add_argument(
        "--compare-methods", action="store_true",
        help="Compare different alignment methods and save results."
    )
    args = parser.parse_args()

    # --- 1. Setup Paths ---
    eng_path = Path(args.english_json)
    ger_path = Path(args.german_json)

    output_dir = Path(config.OUTPUT_DIR)
    output_dir.mkdir(exist_ok=True)

    timestamp = time.strftime("%Y%m%d_%H%M%S")
    if args.output:
        output_alignment_path = Path(args.output)
    else:
        output_alignment_path = output_dir / f"alignment_{eng_path.stem}_{timestamp}.xlsx"

    output_md_eng_path = output_dir / f"{eng_path.stem}_processed.md"
    output_md_ger_path = output_dir / f"{ger_path.stem}_processed.md"

    # Path for the debug report
    if args.debug_report:
        output_debug_path = output_dir / f"debug_calculations_{eng_path.stem}_{timestamp}.xlsx"
        print(f"Debug Report will be saved to: {output_debug_path}\n")
    else:
        output_debug_path = None

    print("--- Document Alignment Pipeline Started ---")
    print(f"English Source: {eng_path}")
    print(f"German Source:  {ger_path}")
    print(f"Output Alignment Report:  {output_alignment_path}")
    print(f"Alignment Algorithm: {args.algorithm}")
    print(f"Context Window Size: {args.context_window}\n")

    try:
        print("Step 1/5: Processing JSON files...")
        english_content = process_document_json(eng_path)
        german_content = process_document_json(ger_path)
        print(f"-> Extracted {len(english_content)} English segments and {len(german_content)} German segments.\n")
    except FileNotFoundError as e:
        print(f"Error: Input file not found. {e}")
        return
    except Exception as e:
        print(f"An error occurred during JSON processing: {e}")
        return

    print("Step 2/5: Creating verification Markdown files...")
    save_to_markdown(english_content, output_md_eng_path)
    save_to_markdown(german_content, output_md_ger_path)
    print(f"-> Markdown files saved in '{output_dir.resolve()}'\n")

    # If comparison mode is enabled, run the comparison and exit
    if args.compare_methods:
        print("Running comparison of alignment methods...")
        compare_alignment_methods(
            english_content,
            german_content,
            output_dir,
            eng_path.stem,
            args.evaluate
        )
        return

    print("Step 3/5: Performing semantic alignment...")
    aligned_pairs = align_content(
        english_content,
        german_content,
        algorithm=args.algorithm,
        context_window=args.context_window,
        generate_debug_report=args.debug_report,
        debug_report_path=output_debug_path
    )
    print(f"-> Alignment complete. Found {len(aligned_pairs)} aligned pairs.\n")

    print("Step 4/5: Writing alignment report to Excel...")
    save_alignment_report(aligned_pairs, output_alignment_path)
    print(f"-> Alignment report saved to: {output_alignment_path.resolve()}\n")

    if args.evaluate:
        print("Step 5/5: Running AI evaluation pipeline...")
        try:
            evaluation_results = list(run_evaluation_pipeline(aligned_pairs))

            if not evaluation_results:
                print("-> Evaluation complete. No significant errors were found.")
            else:
                print(f"-> Evaluation complete. Found {len(evaluation_results)} potential errors.")
                output_eval_path = output_dir / f"evaluation_report_{eng_path.stem}_{timestamp}.xlsx"
                save_evaluation_report(evaluation_results, output_eval_path)
                print(f"-> Evaluation report saved to: {output_eval_path.resolve()}")

        except RuntimeError as e:
            print(f"\nERROR: Could not run evaluation. {e}")
            print("Please ensure your AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_API_KEY are set in the .env file.")
        except Exception as e:
            print(f"\nAn unexpected error occurred during evaluation: {e}")

    print("\n--- Pipeline Finished Successfully ---")

def compare_alignment_methods(
    english_content: List[ContentItem],
    german_content: List[ContentItem],
    output_dir: Path,
    base_filename: str,
    run_evaluation: bool = False
):
    """
    Compare different alignment methods and save results.

    Args:
        english_content: List of English content items
        german_content: List of German content items
        output_dir: Directory to save output files
        base_filename: Base name for output files
        run_evaluation: Whether to run evaluation on each alignment
    """
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    methods = [
        {"name": "mutual", "context": 0, "desc": "Mutual Best Match"},
        {"name": "hungarian", "context": 0, "desc": "Hungarian Algorithm"},
        {"name": "mutual", "context": 1, "desc": "Mutual Best Match with Context"},
        {"name": "hungarian", "context": 1, "desc": "Hungarian Algorithm with Context"}
    ]

    results = []

    for method in methods:
        print(f"\n--- Testing: {method['desc']} ---")

        # Perform alignment using the current method
        aligned_pairs = align_content(
            english_content,
            german_content,
            algorithm=method["name"],
            context_window=method["context"]
        )

        # Save alignment report
        output_path = output_dir / f"alignment_{base_filename}_{method['name']}_ctx{method['context']}_{timestamp}.xlsx"
        save_alignment_report(aligned_pairs, output_path)
        print(f"-> Alignment report saved to: {output_path}")

        # Calculate statistics
        total_pairs = len(aligned_pairs)
        matched_pairs = sum(1 for pair in aligned_pairs if pair.get('english') and pair.get('german'))
        unmatched_eng = sum(1 for pair in aligned_pairs if pair.get('english') and not pair.get('german'))
        unmatched_ger = sum(1 for pair in aligned_pairs if not pair.get('english') and pair.get('german'))

        # Run evaluation if requested
        eval_errors = 0
        if run_evaluation:
            try:
                print(f"Running evaluation for {method['desc']}...")
                evaluation_results = list(run_evaluation_pipeline(aligned_pairs))
                eval_errors = len(evaluation_results)

                if evaluation_results:
                    eval_path = output_dir / f"eval_{base_filename}_{method['name']}_ctx{method['context']}_{timestamp}.xlsx"
                    save_evaluation_report(evaluation_results, eval_path)
                    print(f"-> Evaluation report saved to: {eval_path}")
            except Exception as e:
                print(f"Evaluation error: {e}")

        # Store results for comparison
        results.append({
            "Method": method['desc'],
            "Total Pairs": total_pairs,
            "Matched Pairs": matched_pairs,
            "Unmatched English": unmatched_eng,
            "Unmatched German": unmatched_ger,
            "Match Rate": f"{matched_pairs/(matched_pairs+unmatched_eng+unmatched_ger):.2%}",
            "Evaluation Errors": eval_errors if run_evaluation else "N/A"
        })

        print(f"-> {method['desc']}: {matched_pairs} matched pairs, {unmatched_eng} unmatched English, {unmatched_ger} unmatched German")

    # Save comparison report
    comparison_df = pd.DataFrame(results)
    comparison_path = output_dir / f"comparison_{base_filename}_{timestamp}.xlsx"
    comparison_df.to_excel(comparison_path, index=False)
    print(f"\nComparison report saved to: {comparison_path}")

    return comparison_df

if __name__ == "__main__":
    main()

// test_1/requirements.txt
openai
azure-core
python-dotenv

# Libraries for data handling and calculations
numpy
scikit-learn
tqdm

# Libraries for dataframes and writing Excel files
pandas
openpyxl

