import json
import pandas as pd
from itertools import zip_longest
import os # Optional: for better path handling if needed

def extract_content(json_path):
    """
    Extracts content from paragraphs identified as titles or section headings
    from an Azure Document Intelligence layout model JSON file, excluding headers/footers.

    Args:
        json_path (str): The path to the JSON file.

    Returns:
        list: A list of content strings.
    """
    content_list = []
    print(f"Reading file: {json_path}")
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # Safely navigate to the paragraphs list
        analyze_result = data.get('analyzeResult', {})
        paragraphs = analyze_result.get('paragraphs', [])

        if not paragraphs:
            print(f"Warning: No paragraphs found or 'paragraphs' key missing in {json_path}")
            return content_list

        # Define the roles we want to INCLUDE (excluding pageHeader, pageFooter)
        desired_roles = {'title', 'sectionHeading'}
        # Define roles to EXPLICITLY EXCLUDE
        excluded_roles = {'pageHeader', 'pageFooter'}

        for paragraph in paragraphs:
            role = paragraph.get('role') # Use .get() for safety
            # Include if it has a desired role OR if it has NO role (treating it as body text)
            # AND explicitly exclude header/footer roles
            if role not in excluded_roles: # Check exclusion first
                if role in desired_roles or role is None: # Include desired roles or general text
                     content = paragraph.get('content', '').strip() # Get content safely and strip whitespace
                     if content: # Add only if content is not empty
                         content_list.append(content)

        print(f"Found {len(content_list)} relevant content blocks in {os.path.basename(json_path)}.")

    except FileNotFoundError:
        print(f"Error: File not found at {json_path}")
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from {json_path}. Check if the file is valid.")
    except Exception as e:
        print(f"An unexpected error occurred while processing {json_path}: {e}")

    return content_list

# --- Main execution ---
if __name__ == "__main__":
    # --- IMPORTANT: Set your file paths here ---
    english_json_path = "REPLACE_WITH_PATH/TO_YOUR/english_file.json"
    german_json_path = "REPLACE_WITH_PATH/TO_YOUR/german_file.json" # You can use the '67g.pdf.json' path you provided
    output_excel_path = "content_comparison_no_headers_footers.xlsx" # Changed output filename
    # ------------------------------------------

    # Check if placeholder paths are still present
    if "REPLACE_WITH_PATH" in english_json_path or "REPLACE_WITH_PATH" in german_json_path:
         print("!!! Please update the 'english_json_path' and 'german_json_path' variables in the script with your actual file paths before running. !!!")
    else:
        # Extract content from both files
        english_content = extract_content(english_json_path)
        german_content = extract_content(german_json_path)

        # Combine the lists row by row, filling shorter lists with empty strings
        combined_data = list(zip_longest(english_content, german_content, fillvalue=''))

        # Create a pandas DataFrame
        df = pd.DataFrame(combined_data, columns=['English Content', 'German Content']) # Updated column names

        # Save the DataFrame to an Excel file
        try:
            df.to_excel(output_excel_path, index=False, engine='openpyxl') # Using openpyxl engine
            print(f"\nSuccessfully created Excel file: {output_excel_path}")
        except ImportError:
             print("\nError: 'openpyxl' library is required to write Excel files.")
             print("Please install it using: pip install openpyxl")
        except Exception as e:
            print(f"\nError saving Excel file: {e}")
