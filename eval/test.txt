Option Explicit

' ===== CONFIG =====
Const ENABLE_DEFRAG As Boolean = True
Const DEFRAG_MIN_CHARS As Long = 120
Const DEFRAG_SENT_ENDS As String = ".?!:;)""]"

Const PENALTY_1x2 As Double = 12#
Const PENALTY_2x1 As Double = 12#
Const PENALTY_2x2 As Double = 20#
Const PENALTY_SKIP_BASE As Double = 120#
Const PENALTY_SKIP_PER_CHAR As Double = 0.4

' Enum for "Best Practices" to make action codes readable
Private Enum AlignAction
    act_Invalid = 0
    act_1x1 = 1
    act_1x2 = 2
    act_2x1 = 3
    act_2x2 = 4 ' The missing 2x2 action
    act_SkipEN = 5
    act_SkipDE = 6
End Enum

' ========= UTILITIES =========
Private Function CleanText(ByVal s As String) As String
    Dim t As String
    t = Replace(s, ChrW(160), " ")
    t = Replace(t, vbTab, " ")
    t = Replace(t, vbCr, " ")
    t = Replace(t, vbLf, " ")
    t = Replace(t, Chr(11), " ")
    t = Replace(t, Chr(7), "")
    Do While InStr(t, "  ") > 0
        t = Replace(t, "  ", " ")
    Loop
    CleanText = Trim$(t)
End Function

Private Function ParaLen(ByVal s As String) As Long
    ParaLen = Len(Replace(Replace(s, " ", ""), vbTab, ""))
End Function

Private Function SumLen(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As Long
    Dim i As Long, N As Long
    For i = i1 To i2: N = N + ParaLen(arr(i)): Next
    SumLen = N
End Function

Private Function JoinRange(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As String
    Dim i As Long, t As String
    For i = i1 To i2
        If Len(arr(i)) > 0 Then
            If Len(t) > 0 Then
                t = t & vbCrLf & arr(i)
            Else
                t = arr(i)
            End If
        End If
    Next
    JoinRange = t
End Function

Private Function EndsWithAny(ByVal s As String, ByVal chars As String) As Boolean
    If Len(s) = 0 Then Exit Function
    EndsWithAny = InStr(1, chars, Right$(s, 1), vbBinaryCompare) > 0
End Function

Private Sub CollectParagraphs(doc As Document, ByRef texts() As String)
    Dim p As Paragraph, tmp As New Collection, s As String
    For Each p In doc.Paragraphs
        s = CleanText(p.Range.Text)
        If Len(s) > 0 Then tmp.Add s
    Next
    
    If tmp.Count = 0 Then
        ReDim texts(1 To 1)
        texts(1) = "" ' Ensure array is not empty to avoid errors
    Else
        ReDim texts(1 To tmp.Count)
        Dim i As Long
        For i = 1 To tmp.Count: texts(i) = tmp(i): Next
    End If
End Sub

Private Sub DefragmentParas(ByRef arr() As String)
    If Not ENABLE_DEFRAG Then Exit Sub
    If UBound(arr) < 2 Then Exit Sub
    Dim outCol As New Collection, i As Long, buf As String
    For i = LBound(arr) To UBound(arr)
        If Len(buf) = 0 Then
            buf = arr(i)
        Else
            buf = buf & " " & arr(i)
        End If
        Dim enough As Boolean
        enough = (ParaLen(buf) >= DEFRAG_MIN_CHARS) Or EndsWithAny(buf, DEFRAG_SENT_ENDS)
        If enough Then outCol.Add Trim$(buf): buf = ""
    Next
    If Len(buf) > 0 Then outCol.Add Trim$(buf)
    
    ReDim arr(1 To outCol.Count)
    For i = 1 To outCol.Count: arr(i) = outCol(i): Next
End Sub

Private Function BrowseForFile(prompt As String) As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = prompt
        .Filters.Clear
        .Filters.Add "PDF Files", "*.pdf"
        .AllowMultiSelect = False
        If .Show <> -1 Then Exit Function ' User cancelled
        BrowseForFile = .SelectedItems(1)
    End With
End Function

' --- IMPROVED FUNCTION ---
' This now handles errors, uses the Temp folder, and avoids file name clashes.
Private Function ConvertPdfToDocx(pdfPath As String) As String
    On Error GoTo ErrorHandler
    Dim doc As Document: Set doc = Nothing
    Dim docxPath As String
    Dim fso As Object ' Late binding for Scripting.FileSystemObject
    Dim tempFolder As String
    Dim baseName As String
    
    ' Use late binding to avoid needing a library reference
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If Not fso.FileExists(pdfPath) Then GoTo ErrorHandler ' File not found
    
    ' Get a safe temp path
    tempFolder = fso.GetSpecialFolder(2) ' 2 = TemporaryFolder
    baseName = fso.GetBaseName(pdfPath) & "_" & fso.GetTempName() ' Add temp name to avoid clashes
    docxPath = fso.BuildPath(tempFolder, baseName & ".docx")
    
    ' Open PDF and save as DOCX in the temp folder
    Set doc = Documents.Open(FileName:=pdfPath, ConfirmConversions:=False, ReadOnly:=False)
    doc.SaveAs2 FileName:=docxPath, FileFormat:=wdFormatXMLDocument
    doc.Close SaveChanges:=False
    
    ConvertPdfToDocx = docxPath ' Success
    
    Set doc = Nothing
    Set fso = Nothing
    Exit Function

ErrorHandler:
    ConvertPdfToDocx = "" ' Return empty string on failure
    If Not doc Is Nothing Then doc.Close SaveChanges:=False
    Set doc = Nothing
    Set fso = Nothing
End Function

' ========= MAIN =========
Public Sub AlignTranslatedParagraphs_AutoPick()
    ' --- ADDED: Objects for error handling and cleanup ---
    Dim enDoc As Document: Set enDoc = Nothing
    Dim deDoc As Document: Set deDoc = Nothing
    Dim outDoc As Document: Set outDoc = Nothing
    Dim tbl As Table: Set tbl = Nothing
    Dim enDocx As String: enDocx = ""
    Dim deDocx As String: deDocx = ""
    
    ' --- ADDED: Error handling and performance ---
    Application.ScreenUpdating = False
    On Error GoTo ErrorHandler

    ' Browse for first PDF file
    Dim enPDF As String
    enPDF = BrowseForFile("Select the FIRST PDF file (e.g., English):")
    If enPDF = "" Then
        MsgBox "No file selected. Operation cancelled.", vbExclamation
        GoTo Cleanup ' Use cleanup to exit
    End If

    ' Browse for second PDF file
    Dim dePDF As String
    dePDF = BrowseForFile("Select the SECOND PDF file (e.g., German):")
    If dePDF = "" Then
        MsgBox "No file selected. Operation cancelled.", vbExclamation
        GoTo Cleanup ' Use cleanup to exit
    End If

    MsgBox "Selected files:" & vbCrLf & "First: " & enPDF & vbCrLf & "Second: " & dePDF, vbInformation

    ' Convert PDFs
    enDocx = ConvertPdfToDocx(enPDF)
    ' --- ADDED: Check for conversion failure ---
    If enDocx = "" Then
        MsgBox "Failed to convert the first PDF: " & enPDF & vbCrLf & "The file may be corrupt, secured, or Word may not have permission.", vbCritical
        GoTo Cleanup
    End If
    
    deDocx = ConvertPdfToDocx(dePDF)
    ' --- ADDED: Check for conversion failure ---
    If deDocx = "" Then
        MsgBox "Failed to convert the second PDF: " & dePDF & vbCrLf & "The file may be corrupt, secured, or Word may not have permission.", vbCritical
        GoTo Cleanup
    End If
    
    ' Open
    Set enDoc = Documents.Open(enDocx, ReadOnly:=True)
    Set deDoc = Documents.Open(deDocx, ReadOnly:=True)

    ' Paragraphs
    Dim EN() As String, DE() As String
    CollectParagraphs enDoc, EN
    CollectParagraphs deDoc, DE
    DefragmentParas EN: DefragmentParas DE

    ' Ratio
    Dim i As Long, sumEN As Long, sumDE As Long
    For i = LBound(EN) To UBound(EN): sumEN = sumEN + ParaLen(EN(i)): Next
    For i = LBound(DE) To UBound(DE): sumDE = sumDE + ParaLen(DE(i)): Next
    Dim r As Double
    If sumEN > 0 Then
        r = sumDE / sumEN
    Else
        r = 1#
    End If

    ' DP arrays
    Dim N As Long, M As Long: N = UBound(EN): M = UBound(DE)
    Dim cost() As Double
    ' --- CHANGED: Use Enum for backA ---
    Dim backA() As AlignAction
    Dim backI() As Long, backJ() As Long
    ReDim cost(0 To N, 0 To M)
    ReDim backA(0 To N, 0 To M)
    ReDim backI(0 To N, 0 To M): ReDim backJ(0 To N, 0 To M)
    
    Dim INF As Double: INF = 1E+30
    Dim j As Long
    For i = 0 To N: For j = 0 To M: cost(i, j) = INF: Next: Next
    cost(0, 0) = 0

    Dim c As Double
    For i = 0 To N
        For j = 0 To M
            If cost(i, j) < INF Then
                ' 1x1 alignment
                If i + 1 <= N And j + 1 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 1, r, 0#)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 1, cost(i, j) + c, act_1x1, i, j
                End If
                ' 1x2 alignment
                If i + 1 <= N And j + 2 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 2, r, PENALTY_1x2)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 2, cost(i, j) + c, act_1x2, i, j
                End If
                ' 2x1 alignment
                If i + 2 <= N And j + 1 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 2, j + 1, j + 1, r, PENALTY_2x1)
                    UpdateCell cost, backA, backI, backJ, i + 2, j + 1, cost(i, j) + c, act_2x1, i, j
                End If
                
                ' --- ADDED: 2x2 alignment ---
                If i + 2 <= N And j + 2 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 2, j + 1, j + 2, r, PENALTY_2x2)
                    UpdateCell cost, backA, backI, backJ, i + 2, j + 2, cost(i, j) + c, act_2x2, i, j
                End If
                
                ' Skip EN paragraph
                If i + 1 <= N Then
                    c = PENALTY_SKIP_BASE + PENALTY_SKIP_PER_CHAR * ParaLen(EN(i + 1))
                    UpdateCell cost, backA, backI, backJ, i + 1, j, cost(i, j) + c, act_SkipEN, i, j
                End If
                ' Skip DE paragraph
                If j + 1 <= M Then
                    c = PENALTY_SKIP_BASE + PENALTY_SKIP_PER_CHAR * ParaLen(DE(j + 1))
                    UpdateCell cost, backA, backI, backJ, i, j + 1, cost(i, j) + c, act_SkipDE, i, j
                End If
            End If
        Next
    Next

    ' Backtrack
    Dim pairs As New Collection, i1 As Long: i1 = N
    Dim j1 As Long: j1 = M
    Do While Not (i1 = 0 And j1 = 0)
        ' --- CHANGED: Use Enum for action ---
        Dim a As AlignAction
        Dim pi As Long, pj As Long, rec As Variant
        a = backA(i1, j1): pi = backI(i1, j1): pj = backJ(i1, j1)
        rec = Array(a, pi + 1, i1, pj + 1, j1)
        pairs.Add rec
        i1 = pi: j1 = pj
    Loop

    ' Close source documents
    enDoc.Close SaveChanges:=False
    deDoc.Close SaveChanges:=False
    Set enDoc = Nothing: Set deDoc = Nothing ' Mark as closed

    ' Output table
    Set outDoc = Documents.Add
    Dim rows As Long: rows = pairs.Count + 1
    Set tbl = outDoc.Tables.Add(Range:=outDoc.Range(0, 0), NumRows:=rows, NumColumns:=3)
    tbl.Style = "Table Grid"
    tbl.Cell(1, 1).Range.Text = "English"
    tbl.Cell(1, 2).Range.Text = "German"
    tbl.Cell(1, 3).Range.Text = "Mapping"
    
    ' --- FIX 1: Declared 'a' here ---
    Dim k As Long, rcd As Variant, enFrom As Long, enTo As Long, deFrom As Long, deTo As Long, a As AlignAction
    For k = pairs.Count To 1 Step -1
        rcd = pairs(k)
        a = rcd(0): enFrom = rcd(1): enTo = rcd(2): deFrom = rcd(3): deTo = rcd(4)
        Dim rowIx As Long: rowIx = pairs.Count - k + 2
        tbl.Cell(rowIx, 1).Range.Text = JoinRange(EN, enFrom, enTo)
        tbl.Cell(rowIx, 2).Range.Text = JoinRange(DE, deFrom, deTo)
        tbl.Cell(rowIx, 3).Range.Text = enFrom & "-" & enTo & " ? " & deFrom & "-" & deTo
    Next
    
    ' Auto-fit table
    tbl.AutoFitBehavior wdAutoFitContent
    tbl.AutoFitBehavior wdAutoFitWindow
    
    MsgBox "Alignment complete. Table ready in new document.", vbInformation

' --- ADDED: Cleanup and Error Handler labels ---
Cleanup:
    ' This block runs on successful completion OR on error
    Application.ScreenUpdating = True
    
    ' Close any documents that might still be open
    If Not enDoc Is Nothing Then enDoc.Close SaveChanges:=False
    If Not deDoc Is Nothing Then deDoc.Close SaveChanges:=False
    
    ' Clean up temporary .docx files
    On Error Resume Next ' Ignore errors if files are already deleted or locked
    If Len(enDocx) > 0 Then Kill enDocx
    If Len(deDocx) > 0 Then Kill deDocx
    On Error GoTo 0
    
    ' Release all object variables
    Set enDoc = Nothing
    Set deDoc = Nothing
    Set outDoc = Nothing
    Set tbl = Nothing
    ' --- FIX 2: Removed 'Set fd = Nothing' ---
    Exit Sub ' This is the final exit point

ErrorHandler:
    ' This block only runs if an error occurred
    MsgBox "An error occurred:" & vbCrLf & vbCrLf & _
           "Error " & Err.Number & ": " & Err.Description & vbCrLf & _
           "Procedure: AlignTranslatedParagraphs_AutoPick", _
           vbCritical, "Alignment Failed"
    
    ' Go to the cleanup block to close files and reset the application
    GoTo Cleanup
End Sub


Private Function AlignCost(EN() As String, DE() As String, ei1 As Long, ei2 As Long, dj1 As Long, dj2 As Long, ratio As Double, penalty As Double) As Double
    Dim lenEN As Long: lenEN = SumLen(EN, ei1, ei2)
    Dim lenDE As Long: lenDE = SumLen(DE, dj1, dj2)
    Dim dev As Double: dev = Abs(lenDE - lenEN * ratio)
    AlignCost = dev ^ 0.9 + penalty
End Function

' --- CHANGED: Use Enum for action types ---
Private Sub UpdateCell(ByRef cost() As Double, ByRef backA() As AlignAction, ByRef backI() As Long, ByRef backJ() As Long, ni As Long, nj As Long, newCost As Double, action As AlignAction, pi As Long, pj As Long)
    If newCost < cost(ni, nj) Then
        cost(ni, nj) = newCost
        backA(ni, nj) = action
        backI(ni, nj) = pi
        backJ(ni, nj) = pj
    End If
End Sub
