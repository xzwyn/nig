// test_1/src/alignment/toc_aligner.py
# test_1/src/alignment/toc_aligner.py
from typing import List, Dict, Any
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from scipy.optimize import linear_sum_assignment
from src.clients.azure_client import get_embeddings # Uses the existing Azure client

# Type Aliases
ToCItem = Dict[str, Any]
AlignedToCPair = Dict[str, Any]

def align_tocs(english_toc: List[ToCItem], german_toc: List[ToCItem]) -> List[AlignedToCPair]:
    """
    Aligns Table of Contents sections using Azure OpenAI embeddings and the Hungarian algorithm.
    """
    if not english_toc or not german_toc:
        return []

    eng_titles = [item['title'] for item in english_toc]
    ger_titles = [item['title'] for item in german_toc]

    print("Getting embeddings for ToC titles...")
    english_embeddings = np.array(get_embeddings(eng_titles))
    german_embeddings = np.array(get_embeddings(ger_titles))

    similarity_matrix = cosine_similarity(english_embeddings, german_embeddings)

    # Use the Hungarian algorithm for optimal assignment
    cost_matrix = -similarity_matrix
    row_indices, col_indices = linear_sum_assignment(cost_matrix)

    aligned_sections: List[AlignedToCPair] = []
    print("Matching ToC sections...")
    for eng_idx, ger_idx in zip(row_indices, col_indices):
        score = similarity_matrix[eng_idx, ger_idx]
        # Use a reasonable threshold to filter out poor matches
        if score > 0.5:
            aligned_sections.append({
                'english': english_toc[eng_idx],
                'german': german_toc[ger_idx],
                'similarity': score
            })
    
    aligned_sections.sort(key=lambda x: x['english']['start_page'])
    return aligned_sections

// test_1/config.py
# test_1/config.py
import os
from dotenv import load_dotenv

load_dotenv()

AZURE_EMBEDDING_ENDPOINT = os.getenv("AZURE_EMBEDDING_ENDPOINT")
AZURE_EMBEDDING_API_KEY = os.getenv("AZURE_EMBEDDING_API_KEY")
AZURE_EMBEDDING_DEPLOYMENT_NAME = os.getenv("AZURE_EMBEDDING_DEPLOYMENT_NAME")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-02-01")

IGNORED_ROLES = {'pageHeader', 'pageFooter', 'pageNumber'}
STRUCTURAL_ROLES = {'title', 'sectionHeading'}

W_SEMANTIC = 1  # Weight for semantic similarity (cosine score)
W_TYPE = 0      # Weight for matching content types (e.g., table vs. table)
W_PROXIMITY = 0 # Weight for relative position in the document

TYPE_MATCH_BONUS = 0.1
TYPE_MISMATCH_PENALTY = -0.2

# --- UPDATED THRESHOLDS TO FORCE PAIRING ---
# A very low threshold ensures that the best possible match is always kept,
# regardless of its quality. This forces a comprehensive pairing.
SIMILARITY_THRESHOLD = -1.0

# The minimum margin score for a pair to be considered. Set to -1.0 to accept all pairs.
MARGIN_SCORE_THRESHOLD = -1.0


INPUT_DIR: str = "input"
OUTPUT_DIR: str = "output"

// test_1/src/alignment/semantic_aligner.py
from typing import List, Dict, Any, Tuple
from pathlib import Path
import numpy as np
from openai import AzureOpenAI
from tqdm import tqdm
import faiss

import config
# Use the central Azure client now
from src.clients.azure_client import _get_embedding_client

# Type Aliases for clarity
ContentItem = Dict[str, Any]
AlignedPair = Dict[str, Any]


def _get_embeddings_in_batches(
    texts: List[str],
    content_items: List[ContentItem],
    client: AzureOpenAI, # Now accepts the client as an argument
    batch_size: int = 16,
    context_window: int = 0
) -> np.ndarray:
    """
    Generates embeddings by sending texts to the Azure API in batches.
    Optionally includes context from surrounding segments.
    """
    if context_window > 0:
        texts_with_context = []
        for i, text in enumerate(texts):
            pre_context = "".join([f"{content_items[j]['text']} " for j in range(max(0, i - context_window), i)])
            post_context = "".join([f" {content_items[j]['text']}" for j in range(i + 1, min(len(texts), i + context_window + 1))])
            content_type = content_items[i]['type']
            page_num = content_items[i]['page']
            context_text = f"{pre_context}[SEP]{text}[SEP]{post_context} [TYPE:{content_type}] [PAGE:{page_num}]".strip()
            texts_with_context.append(context_text)
        texts_to_embed = texts_with_context
    else:
        texts_to_embed = texts

    all_embeddings = []
    for i in tqdm(range(0, len(texts_to_embed), batch_size), desc="Generating Embeddings"):
        batch = texts_to_embed[i:i + batch_size]
        try:
            response = client.embeddings.create(input=batch, model=config.AZURE_EMBEDDING_DEPLOYMENT_NAME)
            batch_embeddings = [item.embedding for item in response.data]
            all_embeddings.extend(batch_embeddings)
        except Exception as e:
            print(f"An error occurred while processing a batch: {e}")
            # Use the correct embedding dimension for your model (e.g., 3072 for text-embedding-3-large)
            all_embeddings.extend([[0.0] * 3072] * len(batch))

    return np.array(all_embeddings, dtype='float32')


def _score_candidates_vectorized(
    x: np.ndarray,
    y: np.ndarray,
    ind: np.ndarray,
    x_mean: np.ndarray,
    y_mean: np.ndarray
) -> np.ndarray:
    """
    Calculates margin scores for candidates using vectorized NumPy operations for high performance.
    """
    # 1. Use advanced indexing to get the embeddings of all 'k' neighbors
    y_neighbors = y[ind]

    # 2. Calculate dot product (cosine similarity) for all pairs at once using einsum
    cosine_similarities = np.einsum('ik,ijk->ij', x, y_neighbors)

    # 3. Get the mean similarity of the neighbors
    y_mean_neighbors = y_mean[ind]

    # 4. Calculate the average of source and target mean similarities
    avg_mean_sim = (x_mean[:, np.newaxis] + y_mean_neighbors) / 2

    # 5. Calculate the margin score for all candidates. Add epsilon to avoid division by zero.
    margin = lambda a, b: a / b
    scores = margin(cosine_similarities, avg_mean_sim + 1e-9)

    return scores


def _calculate_margin_scores_and_matches(
    source_embeds: np.ndarray,
    target_embeds: np.ndarray,
    k: int = 4
) -> List[Tuple[int, int, float, float]]:
    """
    Calculates alignment scores using the margin method and returns the best 1-to-1 matches.
    Now also returns the original cosine similarity to avoid redundant calculations.
    """
    # 1. Normalize embeddings for cosine similarity
    source_embeds = source_embeds / np.linalg.norm(source_embeds, axis=1, keepdims=True)
    target_embeds = target_embeds / np.linalg.norm(target_embeds, axis=1, keepdims=True)

    # 2. Find k-Nearest Neighbors (kNN) using FAISS
    index_target = faiss.IndexFlatIP(target_embeds.shape[1])
    index_target.add(target_embeds)
    sim_fwd, ind_fwd = index_target.search(source_embeds, k)

    index_source = faiss.IndexFlatIP(source_embeds.shape[1])
    index_source.add(source_embeds)
    sim_bwd, ind_bwd = index_source.search(target_embeds, k)

    # 3. Calculate mean similarities
    mean_fwd_sim = sim_fwd.mean(axis=1)
    mean_bwd_sim = sim_bwd.mean(axis=1)

    # 4. Calculate margin scores using the new vectorized function
    scores_fwd = _score_candidates_vectorized(source_embeds, target_embeds, ind_fwd, mean_fwd_sim, mean_bwd_sim)
    scores_bwd = _score_candidates_vectorized(target_embeds, source_embeds, ind_bwd, mean_bwd_sim, mean_fwd_sim)

    # 5. Find the best matches
    fwd_best_idx = ind_fwd[np.arange(source_embeds.shape[0]), scores_fwd.argmax(axis=1)]
    bwd_best_idx = ind_bwd[np.arange(target_embeds.shape[0]), scores_bwd.argmax(axis=1)]

    # 6. Combine and enforce 1-to-1 mapping
    potential_matches = []
    fwd_scores_max = scores_fwd.max(axis=1)
    fwd_scores_argmax = scores_fwd.argmax(axis=1)

    for i in range(source_embeds.shape[0]):
        cosine_sim = sim_fwd[i, fwd_scores_argmax[i]]
        potential_matches.append((i, fwd_best_idx[i], fwd_scores_max[i], cosine_sim))

    bwd_scores_max = scores_bwd.max(axis=1)
    bwd_scores_argmax = scores_bwd.argmax(axis=1)
    for i in range(target_embeds.shape[0]):
        cosine_sim = sim_bwd[i, bwd_scores_argmax[i]]
        potential_matches.append((bwd_best_idx[i], i, bwd_scores_max[i], cosine_sim))

    potential_matches.sort(key=lambda x: x[2], reverse=True) # Sort by margin score

    final_matches = []
    seen_source = set()
    seen_target = set()
    for src_idx, trg_idx, margin_score, cos_sim in potential_matches:
        if src_idx not in seen_source and trg_idx not in seen_target:
            final_matches.append((src_idx, trg_idx, margin_score, cos_sim))
            seen_source.add(src_idx)
            seen_target.add(trg_idx)

    return final_matches


def align_content(
    english_content: List[ContentItem],
    german_content: List[ContentItem],
    context_window: int = 0
) -> List[AlignedPair]:
    """
    Aligns content using margin-based scoring, forcing a pair for all possible items.
    """
    if not english_content or not german_content:
        return []

    client = _get_embedding_client() # Use the central client

    # 1. Get embeddings
    english_embeddings = _get_embeddings_in_batches(
        [item['text'] for item in english_content], english_content, client, context_window=context_window
    )
    german_embeddings = _get_embeddings_in_batches(
        [item['text'] for item in german_content], german_content, client, context_window=context_window
    )

    # 2. Get the best 1-to-1 matches using the new margin-based method
    print("Finding best 1-to-1 matches using margin-based scoring...")
    best_matches = _calculate_margin_scores_and_matches(english_embeddings, german_embeddings)

    # 3. Create the list of aligned pairs
    aligned_pairs: List[AlignedPair] = []
    used_english_indices = set()
    used_german_indices = set()

    for eng_idx, ger_idx, margin_score, cos_sim in best_matches:
        if (cos_sim >= config.SIMILARITY_THRESHOLD and margin_score >= config.MARGIN_SCORE_THRESHOLD):
            aligned_pairs.append({
                "english": english_content[eng_idx],
                "german": german_content[ger_idx],
                "similarity": float(cos_sim),
                "margin_score": float(margin_score) # Add margin score for debug reports
            })
            used_english_indices.add(eng_idx)
            used_german_indices.add(ger_idx)

    # 4. Add unmatched content
    for i, item in enumerate(english_content):
        if i not in used_english_indices:
            aligned_pairs.append({"english": item, "german": None, "similarity": 0.0, "margin_score": 0.0})

    for i, item in enumerate(german_content):
        if i not in used_german_indices:
            aligned_pairs.append({"english": None, "german": item, "similarity": 0.0, "margin_score": 0.0})

    # 5. Sort the final list by the English document page order
    aligned_pairs.sort(key=lambda x: x['english']['page'] if x.get('english') else float('inf'))

    return aligned_pairs

// test_1/src/clients/azure_client.py
import os
from typing import List, Dict, Any, Optional
from openai import AzureOpenAI
from dotenv import load_dotenv
load_dotenv()

_chat_client: Optional[AzureOpenAI] = None
_embedding_client: Optional[AzureOpenAI] = None

_cfg = {
    "chat_endpoint": None,
    "chat_api_key": None,
    "chat_api_version": None,
    "chat_deployment": None,
    "embedding_endpoint": None,
    "embedding_api_key": None,
    "embedding_api_version": None,
    "embedding_deployment": None,
}

def _load_env():
    # Chat configuration
    _cfg["chat_endpoint"] = os.getenv("AZURE_OPENAI_ENDPOINT")
    _cfg["chat_api_key"] = os.getenv("AZURE_OPENAI_API_KEY")
    _cfg["chat_api_version"] = os.getenv("AZURE_OPENAI_API_VERSION", "2024-02-01")
    _cfg["chat_deployment"] = os.getenv("AZURE_OPENAI_DEPLOYMENT")

    # Embedding configuration
    _cfg["embedding_endpoint"] = os.getenv("AZURE_EMBEDDING_ENDPOINT")
    _cfg["embedding_api_key"] = os.getenv("AZURE_EMBEDDING_API_KEY")
    _cfg["embedding_api_version"] = os.getenv("AZURE_API_VERSION", "2024-02-01")
    _cfg["embedding_deployment"] = os.getenv("AZURE_EMBEDDING_DEPLOYMENT_NAME")

def _get_chat_client() -> AzureOpenAI:
    global _chat_client
    if _chat_client is not None:
        return _chat_client

    _load_env()
    if not _cfg["chat_endpoint"] or not _cfg["chat_api_key"] or not _cfg["chat_deployment"]:
        raise RuntimeError(
            "Azure OpenAI chat client is not configured. "
            "Set AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_API_KEY, and AZURE_OPENAI_DEPLOYMENT in your .env file."
        )

    _chat_client = AzureOpenAI(
        azure_endpoint=_cfg["chat_endpoint"],
        api_key=_cfg["chat_api_key"],
        api_version=_cfg["chat_api_version"],
    )
    return _chat_client

def _get_embedding_client() -> AzureOpenAI:
    global _embedding_client
    if _embedding_client is not None:
        return _embedding_client

    _load_env()
    if not _cfg["embedding_endpoint"] or not _cfg["embedding_api_key"] or not _cfg["embedding_deployment"]:
        raise RuntimeError(
            "Azure OpenAI embedding client is not configured. "
            "Set AZURE_EMBEDDING_ENDPOINT, AZURE_EMBEDDING_API_KEY, and AZURE_EMBEDDING_DEPLOYMENT_NAME in your .env file."
        )

    _embedding_client = AzureOpenAI(
        azure_endpoint=_cfg["embedding_endpoint"],
        api_key=_cfg["embedding_api_key"],
        api_version=_cfg["embedding_api_version"] or _cfg["chat_api_version"],
    )
    return _embedding_client

def chat(messages: List[Dict[str, Any]], temperature: float = 0.1, model: Optional[str] = None) -> str:
    client = _get_chat_client()
    deployment = model or _cfg["chat_deployment"]

    resp = client.chat.completions.create(
        model=deployment,
        messages=messages,
        temperature=temperature,
    )
    return resp.choices[0].message.content or ""

def get_embeddings(texts: List[str], model: Optional[str]=None) -> List[List[float]]:
    client = _get_embedding_client()
    deployment = model or _cfg['embedding_deployment']

    if not deployment:
        raise ValueError("No embedding deployment specified. Please set AZURE_EMBEDDING_DEPLOYMENT_NAME in your .env file.")

    response = client.embeddings.create(
        input=texts,
        model=deployment
    )
    return [item.embedding for item in response.data]

// test_1/src/clients/doc_intelligence_client.py
# test_1/src/clients/doc_intelligence_client.py
import os
import json
from datetime import datetime
from pathlib import Path

from azure.core.credentials import AzureKeyCredential
from azure.ai.documentintelligence import DocumentIntelligenceClient

import config

def analyze_pdf(pdf_bytes: bytes, original_filename: str) -> dict:
    endpoint = os.getenv("AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT")
    key = os.getenv("AZURE_DOCUMENT_INTELLIGENCE_KEY")

    if not endpoint or not key:
        raise ValueError(
            "Azure Document Intelligence credentials are not configured. "
            "Set AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT and AZURE_DOCUMENT_INTELLIGENCE_KEY in your .env file."
        )

    print(f"Connecting to Document Intelligence service for '{original_filename}'...")
    client = DocumentIntelligenceClient(endpoint=endpoint, credential=AzureKeyCredential(key))

    poller = client.begin_analyze_document(model_id="prebuilt-layout", body=pdf_bytes, content_type="application/pdf")
    result = poller.result()
    print("-> Analysis complete.")

    # Robust serialization across SDK versions; wrap with expected top-level key
    try:
        ar_dict = result.as_dict()  # newer SDKs
    except AttributeError:
        try:
            ar_dict = result.to_dict()  # older SDKs
        except AttributeError:
            # Manual fallback
            ar_dict = {
                "content": getattr(result, "content", ""),
                "pages": [p.as_dict() if hasattr(p, "as_dict") else (p.to_dict() if hasattr(p, "to_dict") else {}) for p in getattr(result, "pages", [])],
                "paragraphs": [x.as_dict() if hasattr(x, "as_dict") else (x.to_dict() if hasattr(x, "to_dict") else {}) for x in getattr(result, "paragraphs", [])],
                "tables": [t.as_dict() if hasattr(t, "as_dict") else (t.to_dict() if hasattr(t, "to_dict") else {}) for t in getattr(result, "tables", [])],
                "styles": [s.as_dict() if hasattr(s, "as_dict") else (s.to_dict() if hasattr(s, "to_dict") else {}) for s in getattr(result, "styles", [])],
            }

    result_dict = {"analyzeResult": ar_dict}

    # Save JSON for reference
    output_dir = Path(config.OUTPUT_DIR)
    output_dir.mkdir(exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base_name = Path(original_filename).stem
    output_filename = f"doc_intelligence_{base_name}_{timestamp}.json"
    output_path = output_dir / output_filename

    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(result_dict, f, ensure_ascii=False, indent=4)
        print(f"-> Saved Document Intelligence JSON to '{output_path}'")
    except Exception as e:
        print(f"Warning: Could not save JSON output for '{original_filename}'. Reason: {e}")

    return result_dict

// test_1/src/evaluation/evaluators.py
# src/evaluation/evaluators.py
import json
from src.clients.azure_client import chat  

def evaluate_translation_pair(eng_text: str, ger_text: str, model_name=None):
    prompt = f"""
## ROLE
You are the Primary Translation Auditor for EN→DE corporate reports.

## TASK
Identify only the two fatal error categories below and output ONE JSON object.

## ERROR TYPES YOU MAY REPORT
1. Mistranslation
   • Wrong numeric value (digits, words, units, decimals, percentages)
   • Polarity flip / negation error (e.g., required ↔ not required)
   • Change of actor or agency (who did/decided/informed whom)

2. Omission
   The English text states a concrete count (“two”, “three”, “both”, “either”) or lists specific items, and at least one required element is missing in German.

Do not flag: stylistic differences, safe synonyms, acceptable German report titles (“Nichtfinanzielle Erklärung”, “Erklärung zur Unternehmensführung” etc.), benign reordering, or tense/voice changes that preserve actor and meaning.

If no fatal error is found, return error_type "None".

If multiple fatal errors exist, choose the most impactful; if tied, prefer "Mistranslation".

## JSON OUTPUT SCHEMA
json {{ "error_type" : "Mistranslation" | "Omission" | "None", "original_phrase" : "", "translated_phrase": "", "explanation" : "<≤40 words>", "suggestion" : "" }}

## POSITIVE EXAMPLES
1 · Mistranslation (number)
EN “Revenue increased by 2.3 million.”
DE “Der Umsatz stieg um 2,8 Millionen.”
→ error_type “Mistranslation”, original “2.3 million”, translated “2,8 Millionen”

2 · Mistranslation (polarity)
EN “The audit is not required.”
DE “Die Prüfung ist erforderlich.”
→ error_type “Mistranslation”, original “not required”, translated “erforderlich”

3 · Mistranslation (actor/agency)
EN “The company was notified by the regulator.”
DE “Das Unternehmen informierte die Aufsichtsbehörde.”
→ error_type “Mistranslation”, original “was notified by the regulator”, translated “informierte die Aufsichtsbehörde”

4 · Omission (enumeration/count)
EN “Both measures will apply: cost cap and hiring freeze.”
DE “Es gilt die Einstellungsstop.”
→ error_type “Omission”, original “cost cap”, translated “”

5 · None (acceptable variation)
EN “The report is comprehensive.”
DE “Der Bericht ist umfassend.”
→ error_type “None”

## TEXTS TO AUDIT
<Original English>
{eng_text}
</Original English>

<German Translation>
{ger_text}
</German Translation>

## YOUR RESPONSE
Return the JSON object only—no extra text, no markdown.

## NOTES
- Compare all numbers, signs, and units (%, bps, million/Mio., billion/Mrd.).
- Treat passive/active voice as fine unless the responsible actor changes.
- For omissions, ensure every counted or listed element appears in German.
- Keep “explanation” concise; “suggestion” should minimally correct the German (or note the missing item).
"""
    try:
        content = chat(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            model=model_name,
        ).strip()

        j0, j1 = content.find("{"), content.rfind("}") + 1
        if j0 != -1 and j1 != -1:
            return json.loads(content[j0:j1])
        return {"error_type": "System Error",
                "explanation": "No JSON object in LLM reply."}
    except Exception as exc:
        print(f"evaluate_translation_pair → {exc}")
        return {"error_type": "System Error", "explanation": str(exc)}

def check_context_mismatch(eng_text: str, ger_text: str, model_name: str = None):
    prompt = f"""
ROLE: Narrative-Integrity Analyst

Goal: Decide if the German text tells a **different story** from the
English.  “Different” means a change in
• WHO does WHAT to WHOM
• factual outcome or direction of action
• polarity (e.g. “comprehensive” ↔ “unvollständig”)

Ignore style, word order, or minor re-phrasing.

Respond with JSON:

{{
  "context_match": "Yes" | "No",
  "explanation":  "<one concise sentence>"
}}

Examples
--------
1) Role reversal (should be No)
EN  Further, the committee *was informed* by the Board …
DE  Darüber hinaus *leitete der Ausschuss eine Untersuchung ein* …
→ roles flipped ⇒ "No"

2) Identical meaning (Yes)
EN  Declaration of Conformity with the German Corporate Governance Code
DE  Entsprechenserklärung zum Deutschen Corporate Governance Kodex
→ "Yes"

Analyse the following text pair and respond with the JSON only.

<Original_English>
{eng_text}
</Original_English>

<German_Translation>
{ger_text}
</German_Translation>
"""
    try:
        content = chat(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            model=model_name,
        ).strip()

        j0, j1 = content.find("{"), content.rfind("}") + 1
        return json.loads(content[j0:j1])
    except Exception as exc:
        return {"context_match": "Error", "explanation": str(exc)}

// test_1/src/evaluation/pipeline.py
# src/evaluation/pipeline.py
import json
from typing import List, Dict, Any, Optional
from tqdm import tqdm

from src.evaluation.evaluators import evaluate_translation_pair, check_context_mismatch
from src.clients.azure_client import chat

__all__ = ["run_evaluation_pipeline"]

AlignedPair = Dict[str, Any]
EvaluationFinding = Dict[str, Any]

def _agent2_validate_finding(
    eng_text: str,
    ger_text: str,
    error_type: str,
    explanation: str,
    model_name: Optional[str] = None,
):
    """
    Second-stage reviewer.  Confirms only truly fatal errors and rejects
    false positives.
    """
    prompt = f"""
## ROLE
**Senior Quality Reviewer** – you are the final gatekeeper of EN→DE
translation findings.

## TASK
Decide whether the finding delivered by Agent-1 must be *Confirmed* or
*Rejected*.

## INSTRUCTIONS
1. Eligible error_type values are **exactly**:
   • "Mistranslation"  
   • "Omission"

2. Confirm only when the evidence is unmistakable:
   • Mistranslation
       – number mismatch (digit or word)  
       – polarity flip / opposite meaning  
       – actor/role inversion  
   • Omission
       – English states an explicit count (“two”, “three”, “both” …) **or**
         lists concrete items, and at least one item is *truly* missing in
         German (not conveyed by paraphrase).

3. Reject when:
   • Difference is stylistic or synonymous.  
   • Proper names / document titles are rendered with an accepted German
     equivalent (e.g. “Nichtfinanzielle Erklärung”).  
   • Alleged omission is actually present via paraphrase.  

## OUTPUT ‑ JSON ONLY
json {{ "verdict" : "Confirm" | "Reject", "reasoning": "" }}

## MATERIAL TO REVIEW
English text:
\"\"\"{eng_text}\"\"\"

German text:
\"\"\"{ger_text}\"\"\"

Agent-1 proposed:
  error_type : {error_type}
  explanation: {explanation}

## YOUR RESPONSE
Return the JSON object only – no extra text.
"""
    try:
        content = chat(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            model=model_name,
        )
        j0, j1 = content.find("{"), content.rfind("}") + 1
        verdict_json = json.loads(content[j0:j1])
        is_confirmed = verdict_json.get("verdict", "").lower() == "confirm"
        reasoning = verdict_json.get("reasoning", "")
        return is_confirmed, reasoning, content.strip()
    except (ValueError, json.JSONDecodeError) as exc:
        print(f"  - Agent-2 JSON parse error: {exc}")
        return False, f"System error: {exc}", "{}"
    except Exception as exc:
        print(f"  - Agent-2 unexpected error: {exc}")
        return False, "System error (non-parsing issue)", "{}"

def run_evaluation_pipeline(aligned_pairs: List[AlignedPair]) -> List[EvaluationFinding]:
    findings = []

    for pair in tqdm(aligned_pairs, desc="Evaluating Pairs"):
        eng_elem = pair.get('english')
        ger_elem = pair.get('german')

        if eng_elem and not ger_elem:
            findings.append({
                "type": f"Omission",
                "english_text": eng_elem['text'],
                "german_text": "---",
                "suggestion": "This content from the English document is missing in the German document.",
                "page": eng_elem['page']
            })
            continue

        if not eng_elem and ger_elem:
            findings.append({
                "type": f"Addition",
                "english_text": "---",
                "german_text": ger_elem['text'],
                "suggestion": "This content from the German document does not appear to have a source in the English document.",
                "page": ger_elem['page']
            })
            continue

        if eng_elem and ger_elem:
            eng_text = eng_elem['text']
            ger_text = ger_elem['text']

            # Agent 1
            finding = evaluate_translation_pair(eng_text, ger_text)
            error_type = finding.get("error_type", "None")

            if error_type not in ["None", "System Error"]:
                # Agent 2
                is_confirmed, reasoning, _ = _agent2_validate_finding(
                    eng_text, ger_text, error_type, finding.get("explanation")
                )

                if is_confirmed:
                    findings.append({
                        "type": error_type,
                        "english_text": eng_text,
                        "german_text": ger_text,
                        "suggestion": finding.get("suggestion"),
                        "page": eng_elem.get('page'),
                        "original_phrase": finding.get("original_phrase"),
                        "translated_phrase": finding.get("translated_phrase")
                    })
                else: # Agent 2 rejected, run Agent 3
                    context_result = check_context_mismatch(eng_text, ger_text)
                    context_match_verdict = context_result.get('context_match', 'Error')
                    if context_match_verdict.lower() == "no":
                        findings.append({
                            "type": "Context Mismatch",
                            "english_text": eng_text,
                            "german_text": ger_text,
                            "suggestion": context_result.get("explanation"),
                            "page": eng_elem.get('page')
                        })

    return findings

// test_1/src/processing/json_parser.py
# test_1/src/processing/json_parser.py
import json
from pathlib import Path
from typing import List, Dict, Any

import config

# A type alias for our structured content for clarity
ContentItem = Dict[str, Any]

def _convert_table_to_markdown(table_obj: Dict) -> str:
    """Converts an Azure table object into a Markdown string."""
    markdown_str = ""
    if not table_obj.get('cells'):
        return ""

    # Create header
    header_cells = [cell for cell in table_obj['cells'] if cell.get('kind') == 'columnHeader']
    if header_cells:
        header_cells.sort(key=lambda x: x['columnIndex'])
        # Handle cells that might span multiple columns
        header_content = []
        for cell in header_cells:
            content = cell.get('content', '').strip()
            col_span = cell.get('columnSpan', 1)
            header_content.extend([content] * col_span)

        header_row = "| " + " | ".join(header_content) + " |"
        separator_row = "| " + " | ".join(["---"] * len(header_content)) + " |"
        markdown_str += header_row + "\n" + separator_row + "\n"

    # Create body rows
    body_cells = [cell for cell in table_obj['cells'] if cell.get('kind') is None]

    rows = {}
    for cell in body_cells:
        row_idx = cell.get('rowIndex', 0)
        if row_idx not in rows:
            rows[row_idx] = []
        rows[row_idx].append(cell)

    for row_idx in sorted(rows.keys()):
        row_cells = sorted(rows[row_idx], key=lambda x: x.get('columnIndex', 0))
        row_str = "| " + " | ".join([cell.get('content', '').strip() for cell in row_cells]) + " |"
        markdown_str += row_str + "\n"

    return markdown_str.strip()


def process_document_json(doc_intelligence_data: Any) -> List[ContentItem]:
    # Allow passing a file path or a preloaded dict
    if isinstance(doc_intelligence_data, (str, Path)):
        with open(Path(doc_intelligence_data), 'r', encoding='utf-8') as f:
            doc_intelligence_data = json.load(f)

    try:
        analyze_result = doc_intelligence_data['analyzeResult']
        full_text_content = analyze_result['content']
        raw_paragraphs = analyze_result.get('paragraphs', [])
        pages = analyze_result.get('pages', [])
        raw_tables = analyze_result.get('tables', [])
    except KeyError as e:
        raise ValueError(f"Document Intelligence data is missing expected key: {e}") from e

    # --- Step 1: Identify all character offsets belonging to tables to avoid duplication ---
    table_offsets = set()
    for table in raw_tables:
        for span in table.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                table_offsets.add(i)

    # Identify all character offsets that are handwritten
    handwritten_offsets = set()
    if 'styles' in analyze_result:
        for style in analyze_result['styles']:
            if style.get('isHandwritten') and style.get('spans'):
                for span in style['spans']:
                    for i in range(span['offset'], span['offset'] + span['length']):
                        handwritten_offsets.add(i)

    # Create a quick lookup for page number by span offset
    page_lookup = {}
    for page in pages:
        for span in page.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                page_lookup[i] = page.get('pageNumber', 0)

    # --- Step 2: Extract all content, including tables, and sort by position ---
    all_content: List[ContentItem] = []

    # Process PARAGRAPHS
    for p in raw_paragraphs:
        role = p.get('role', 'paragraph')
        if role in config.IGNORED_ROLES or not p.get('spans'):
            continue

        offset = p['spans'][0]['offset']
        # If the paragraph is inside a table or is handwritten, SKIP it.
        if offset in table_offsets or offset in handwritten_offsets:
            continue

        length = p['spans'][0]['length']
        text = full_text_content[offset : offset + length].strip()
        page_number = page_lookup.get(offset, 0)
        if text:
            all_content.append({'text': text, 'type': role, 'page': page_number, 'offset': offset})

    # Process TABLES
    for table in raw_tables:
        if not table.get('spans'):
            continue
        offset = table['spans'][0]['offset']
        page_number = page_lookup.get(offset, 0)
        markdown_table = _convert_table_to_markdown(table)
        if markdown_table:
            all_content.append({'text': markdown_table, 'type': 'table', 'page': page_number, 'offset': offset})

    # Sort all extracted content by its character offset to maintain document order
    all_content.sort(key=lambda x: x['offset'])

    # --- Step 3: Stitch broken paragraphs ---
    final_content: List[ContentItem] = []
    stitched_text = ""
    current_page = 0
    current_type = "paragraph"

    for i, segment in enumerate(all_content):
        # If the current element is a table or a structural heading, finalize the previous stitched text.
        is_standalone = segment['type'] in config.STRUCTURAL_ROLES or segment['type'] == 'table'

        if is_standalone:
            if stitched_text: # Finalize any pending paragraph
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = ""
            final_content.append(segment) # Add the standalone item
            continue

        # This logic handles stitching of regular paragraphs
        if not stitched_text: # Start a new paragraph
            stitched_text = segment['text']
            current_page = segment['page']
            current_type = segment['type']
        else:
            # If previous text ends with punctuation, start a new paragraph
            if stitched_text.endswith(('.', '!', '?', ':', '•')):
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = segment['text']
                current_page = segment['page']
                current_type = segment['type']
            else: # Continue stitching the current paragraph
                stitched_text += f" {segment['text']}"

    # Add the last stitched paragraph if it exists
    if stitched_text:
        final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})

    return final_content

// test_1/src/processing/toc_parser.py
# test_1/src/processing/toc_parser.py
import re
from pathlib import Path
from typing import List, Dict, Any
import fitz  # PyMuPDF

# A type alias for a structured ToC item
ToCItem = Dict[str, Any]

def get_toc_text_from_pdf(pdf_path: Path, page_num: int = 1) -> str:
    """Extracts raw text from a specific page of a PDF file."""
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found at: {pdf_path}")

    try:
        with fitz.open(pdf_path) as doc:
            if page_num < len(doc):
                page = doc.load_page(page_num)
                return page.get_text("text")
            else:
                # Fallback to first page if specified page doesn't exist
                print(f"Warning: Page {page_num} not found. Falling back to page 0.")
                page = doc.load_page(0)
                return page.get_text("text")
    except Exception as e:
        raise IOError(f"Error opening or reading PDF file '{pdf_path}': {e}") from e

def structure_toc(toc_text: str) -> List[ToCItem]:
    """
    Parses the raw text of a Table of Contents into a structured list of sections,
    including their titles and start pages.
    """
    # Regex to find lines ending with a number, optionally followed by junk to be stripped.
    # It captures the title and the page number.
    # Example: "2. Supervisory Board Report ......... 4"
    section_pattern = re.compile(r"^(.*?)\s*[.\s]+(\d+)\s*$")
    
    structured_list: List[ToCItem] = []
    lines = toc_text.split('\n')

    for line in lines:
        line = line.strip()
        if not line or len(line) < 3: # Ignore empty or very short lines
            continue
            
        match = section_pattern.match(line)
        if match:
            title, page_number_str = match.groups()
            
            # Further clean the title from leading numbers/bullets
            title = re.sub(r"^\s*([A-D]|\d{1,2}[\.\s])\s*[_]?\s*", "", title).strip()
            
            if title and len(title) > 4:  # Ensure title is meaningful
                structured_list.append({
                    'title': title,
                    'start_page': int(page_number_str)
                })

    if not structured_list:
        return []

    # Sort by start page to ensure correct order
    structured_list.sort(key=lambda x: x['start_page'])

    # Calculate the end_page for each section
    for i in range(len(structured_list) - 1):
        structured_list[i]['end_page'] = structured_list[i+1]['start_page'] - 1

    # Set end_page for the last section to a high number
    structured_list[-1]['end_page'] = 999

    return structured_list

// test_1/src/reporting/excel_writer.py
import io
from pathlib import Path
from typing import List, Dict, Any
import pandas as pd

AlignedPair = Dict[str, Any]
EvaluationFinding = Dict[str, Any]

def save_alignment_report(aligned_data: List[AlignedPair], filepath: Path) -> None:
    """
    Saves the document alignment data to an Excel file.
    Now includes margin_score if it's available in the data.
    """
    if not aligned_data:
        print("Warning: No aligned data to save to Excel.")
        return

    report_data = []
    # Check if margin_score is present in the first pair
    has_margin_score = 'margin_score' in aligned_data[0]

    for pair in aligned_data:
        eng_item = pair.get('english')
        ger_item = pair.get('german')
        row = {
            "English": eng_item.get('text', '') if eng_item else "--- OMITTED ---",
            "German": ger_item.get('text', '') if ger_item else "--- ADDED ---",
            "Similarity": f"{pair.get('similarity', 0.0):.4f}",
            "Type": (eng_item.get('type') if eng_item else ger_item.get('type', 'N/A')),
            "English Page": (eng_item.get('page') if eng_item else 'N/A'),
            "German Page": (ger_item.get('page') if ger_item else 'N/A')
        }
        if has_margin_score:
            row["Margin Score"] = f"{pair.get('margin_score', 0.0):.4f}"
        report_data.append(row)

    df = pd.DataFrame(report_data)
    try:
        df.to_excel(filepath, index=False, engine='openpyxl')
    except Exception as e:
        print(f"Error: Could not write alignment report to '{filepath}'. Reason: {e}")


def save_evaluation_report(evaluation_results: List[EvaluationFinding], filepath: Path) -> None:
    """Saves the AI evaluation findings to a separate Excel report."""
    if not evaluation_results:
        print("No evaluation findings to save.")
        return
    evaluation_results.sort(key=lambda x: x.get('page', 0))
    df = pd.DataFrame(evaluation_results)
    desired_columns = [
        "page", "type", "suggestion", "english_text", "german_text",
        "original_phrase", "translated_phrase"
    ]
    final_columns = [col for col in desired_columns if col in df.columns]
    df = df[final_columns]
    try:
        df.to_excel(filepath, index=False, sheet_name='Evaluation_Findings')
    except Exception as e:
        print(f"Error: Could not write evaluation report to '{filepath}'. Reason: {e}")


def save_sectionwise_debug_report(
    section_data: Dict[str, List[AlignedPair]],
    filepath: Path
) -> None:
    """
    Saves a detailed, multi-sheet Excel debug report with one sheet per ToC section.
    """
    if not section_data:
        print("Warning: No section data provided for the debug report.")
        return

    try:
        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
            for section_title, aligned_pairs in section_data.items():
                # Sanitize sheet title (Excel has a 31-char limit and restrictions)
                safe_sheet_name = "".join(c for c in section_title if c.isalnum() or c in " ").strip()
                safe_sheet_name = safe_sheet_name[:31]

                if not aligned_pairs:
                    continue

                report_data = []
                for pair in aligned_pairs:
                    eng_item = pair.get('english')
                    ger_item = pair.get('german')
                    report_data.append({
                        "English Text": eng_item.get('text', '') if eng_item else "--- OMITTED ---",
                        "German Text": ger_item.get('text', '') if ger_item else "--- ADDED ---",
                        "Cosine Similarity": f"{pair.get('similarity', 0.0):.4f}",
                        "Margin Score": f"{pair.get('margin_score', 0.0):.4f}",
                        "Content Type": (eng_item.get('type') if eng_item else ger_item.get('type', 'N/A')),
                        "English Page": (eng_item.get('page') if eng_item else 'N/A'),
                        "German Page": (ger_item.get('page') if ger_item else 'N/A')
                    })
                
                df_section = pd.DataFrame(report_data)
                df_section.to_excel(writer, sheet_name=safe_sheet_name, index=False)
        print(f"-> Section-wise debug report saved to: {filepath.resolve()}")
    except Exception as e:
        print(f"Error: Could not write section-wise debug report to '{filepath}'. Reason: {e}")


def create_excel_report_in_memory(evaluation_results: List[EvaluationFinding]) -> bytes:
    """
    Creates the evaluation Excel report in memory and returns it as bytes.
    """
    if not evaluation_results:
        return b''

    evaluation_results.sort(key=lambda x: x.get('page', 0))
    df = pd.DataFrame(evaluation_results)
    desired_columns = [
        "page", "type", "suggestion", "english_text", "german_text",
        "original_phrase", "translated_phrase"
    ]
    final_columns = [col for col in desired_columns if col in df.columns]
    df = df[final_columns]

    output_buffer = io.BytesIO()
    with pd.ExcelWriter(output_buffer, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Evaluation_Findings')

    return output_buffer.getvalue()

// test_1/src/reporting/markdown_writer.py
from pathlib import Path
from typing import List, Dict, Any

ContentItem = Dict[str, Any]

def save_to_markdown(content: List[ContentItem], filepath: Path) -> None:
    with open(filepath, 'w', encoding='utf-8') as f:
        for item in content:
            if item['type'] in {'title', 'sectionHeading', 'subheading'}:
                f.write(f"## {item['text']}\n\n")
            else:
                f.write(f"{item['text']}\n\n")

// test_1/main.py
# test_1/main.py
import argparse
import time
from pathlib import Path

from dotenv import load_dotenv
load_dotenv()

import config
from src.processing.json_parser import process_document_json
from src.alignment.semantic_aligner import align_content
from src.reporting.markdown_writer import save_to_markdown
from src.reporting.excel_writer import save_alignment_report, save_evaluation_report
from src.evaluation.pipeline import run_evaluation_pipeline

def main():
    parser = argparse.ArgumentParser(
        description="Aligns and optionally evaluates content from two Azure Document Intelligence JSON files."
    )
    parser.add_argument("english_json", type=str, help="Path to the English JSON file.")
    parser.add_argument("german_json", type=str, help="Path to the German JSON file.")
    parser.add_argument(
        "-o", "--output", type=str, help="Path for the output alignment Excel file.",
        default=None
    )
    parser.add_argument(
        "--evaluate", action="store_true",
        help="Run the AI evaluation pipeline after alignment."
    )
    parser.add_argument(
        "--debug-report", action="store_true",
        help="Generate a detailed alignment report including margin scores."
    )
    parser.add_argument(
        "--context-window", type=int, default=1,
        help="Size of context window (default: 1 for context-aware embeddings, 0 for no context)."
    )
    args = parser.parse_args()

    # --- 1. Setup Paths ---
    eng_path = Path(args.english_json)
    ger_path = Path(args.german_json)

    output_dir = Path(config.OUTPUT_DIR)
    output_dir.mkdir(exist_ok=True)

    timestamp = time.strftime("%Y%m%d_%H%M%S")
    base_name = f"{eng_path.stem}_{timestamp}"

    if args.output:
        output_alignment_path = Path(args.output)
    else:
        output_alignment_path = output_dir / f"alignment_{base_name}.xlsx"

    print("--- Document Alignment Pipeline Started ---")
    print(f"English Source: {eng_path}")
    print(f"German Source:  {ger_path}")
    print(f"Alignment Algorithm: Margin-Based (Best Effort)")
    print(f"Context Window Size: {args.context_window}\n")

    try:
        print("Step 1/4: Processing JSON files...")
        english_content = process_document_json(eng_path)
        german_content = process_document_json(ger_path)
        print(f"-> Extracted {len(english_content)} English segments and {len(german_content)} German segments.\n")
    except FileNotFoundError as e:
        print(f"Error: Input file not found. {e}")
        return
    except Exception as e:
        print(f"An error occurred during JSON processing: {e}")
        return

    print("Step 2/4: Creating verification Markdown files...")
    save_to_markdown(english_content, output_dir / f"{eng_path.stem}_processed.md")
    save_to_markdown(german_content, output_dir / f"{ger_path.stem}_processed.md")
    print(f"-> Markdown files saved in '{output_dir.resolve()}'\n")

    print("Step 3/4: Performing semantic alignment...")
    aligned_pairs = align_content(
        english_content,
        german_content,
        context_window=args.context_window,
    )
    print(f"-> Alignment complete. Found {len(aligned_pairs)} aligned pairs.\n")

    print("Step 4/4: Writing alignment report(s) to Excel...")
    save_alignment_report(aligned_pairs, output_alignment_path)
    print(f"-> Main alignment report saved to: {output_alignment_path.resolve()}")
    
    if args.debug_report:
        debug_report_path = output_dir / f"debug_report_{base_name}.xlsx"
        # The same function now smartly includes the margin score for the debug report
        save_alignment_report(aligned_pairs, debug_report_path)
        print(f"-> Debug report with margin scores saved to: {debug_report_path.resolve()}")
    print("")

    if args.evaluate:
        print("Step 5/4: Running AI evaluation pipeline...")
        try:
            evaluation_results = list(run_evaluation_pipeline(aligned_pairs))

            if not evaluation_results:
                print("-> Evaluation complete. No significant errors were found.")
            else:
                print(f"-> Evaluation complete. Found {len(evaluation_results)} potential errors.")
                output_eval_path = output_dir / f"evaluation_report_{base_name}.xlsx"
                save_evaluation_report(evaluation_results, output_eval_path)
                print(f"-> Evaluation report saved to: {output_eval_path.resolve()}")

        except RuntimeError as e:
            print(f"\nERROR: Could not run evaluation. {e}")
        except Exception as e:
            print(f"\nAn unexpected error occurred during evaluation: {e}")

    print("\n--- Pipeline Finished Successfully ---")

if __name__ == "__main__":
    main()

// test_1/requirements.txt
streamlit
openai
azure-core
python-dotenv
azure-ai-documentintelligence
faiss-cpu
PyMuPDF

# Libraries for data handling and calculations
numpy
scikit-learn
tqdm
spicy
# Libraries for dataframes and writing Excel files
pandas
openpyxl

// test_1/app.py
# test_1/app.py
from dotenv import load_dotenv
load_dotenv()

import streamlit as st
from datetime import datetime
import time
from pathlib import Path
import os

# --- Import project modules ---
import config
from src.clients.doc_intelligence_client import analyze_pdf
from src.processing.json_parser import process_document_json
from src.processing.toc_parser import get_toc_text_from_pdf, structure_toc
from src.alignment.toc_aligner import align_tocs
from src.alignment.semantic_aligner import align_content
from src.evaluation.pipeline import run_evaluation_pipeline
from src.reporting.excel_writer import (
    create_excel_report_in_memory,
    save_alignment_report,
    save_evaluation_report,
    save_sectionwise_debug_report # Import the new function
)
from src.reporting.markdown_writer import save_to_markdown

# --- Helper to save uploaded files temporarily ---
def save_temp_file(uploaded_file) -> Path:
    temp_dir = Path("./temp_uploads")
    temp_dir.mkdir(exist_ok=True)
    file_path = temp_dir / uploaded_file.name
    with open(file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())
    return file_path

# --- Page Configuration & UI Functions (unchanged) ---
st.set_page_config(page_title="Translation Evaluator", layout="wide")

def display_results(results_list: list):
    """Renders the list of evaluation findings in the Streamlit UI."""
    if not results_list: return
    st.subheader(f"Found {len(results_list)} noteworthy items")
    results_list.sort(key=lambda x: x.get('page', 0))
    for result in results_list:
        error_type = result.get('type', 'Info')
        with st.container(border=True):
            st.markdown(f"**Page:** `{result.get('page', 'N/A')}` | **Type:** `{error_type}`")
            original_phrase, translated_phrase = result.get("original_phrase"), result.get("translated_phrase")
            if original_phrase or translated_phrase:
                st.markdown("##### 🔍 Error Focus")
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown("**Original English Phrase:**"); st.error(f"'{original_phrase or 'N/A'}'")
                with col2:
                    st.markdown("**Translated German Phrase:**"); st.warning(f"'{translated_phrase or 'N/A'}'")
                st.divider()
            st.markdown("##### Full Text Context")
            col1, col2 = st.columns(2)
            with col1: st.markdown(f"> {result['english_text']}")
            with col2: st.markdown(f"> {result['german_text']}")
            st.markdown(f"**💡 Suggestion:** {result['suggestion']}")

# --- Main App ---
st.title("📚 Translation Evaluator (ToC-Based)")
st.markdown("This tool aligns documents section-by-section based on the Table of Contents for improved accuracy.")
st.divider()

if 'analysis_complete' not in st.session_state: st.session_state.analysis_complete = False
if 'evaluation_results' not in st.session_state: st.session_state.evaluation_results = []
if 'error_message' not in st.session_state: st.session_state.error_message = None

# --- Sidebar for Inputs and Controls ---
with st.sidebar:
    st.header("1. Upload Documents")
    english_pdf = st.file_uploader("Upload English PDF (Source)", type="pdf", key="eng_pdf")
    german_pdf = st.file_uploader("Upload German PDF (Translation)", type="pdf", key="ger_pdf")

    st.header("2. Configure & Run")
    toc_page_num = st.number_input("ToC Page Number in PDF", min_value=1, max_value=20, value=2) - 1

    if st.button("🚀 Run Analysis", disabled=not (english_pdf and german_pdf), type="primary"):
        st.session_state.analysis_complete = False
        st.session_state.evaluation_results = []
        st.session_state.error_message = None

        output_dir = Path(config.OUTPUT_DIR)
        output_dir.mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"{Path(english_pdf.name).stem}_{timestamp}"
        
        eng_temp_path, ger_temp_path = None, None # Define before try block
        try:
            final_aligned_pairs = []
            section_debug_data = {} # To store data for the debug report

            with st.spinner("Step 1/8: Analyzing PDFs with Azure Document Intelligence..."):
                eng_json_data = analyze_pdf(english_pdf.getvalue(), english_pdf.name)
                ger_json_data = analyze_pdf(german_pdf.getvalue(), german_pdf.name)

            with st.spinner("Step 2/8: Processing full document content..."):
                full_english_content = process_document_json(eng_json_data)
                full_german_content = process_document_json(ger_json_data)

            with st.spinner("Step 3/8: Extracting and structuring Tables of Contents..."):
                eng_temp_path = save_temp_file(english_pdf)
                ger_temp_path = save_temp_file(german_pdf)
                english_toc = structure_toc(get_toc_text_from_pdf(eng_temp_path, page_num=toc_page_num))
                german_toc = structure_toc(get_toc_text_from_pdf(ger_temp_path, page_num=toc_page_num))

            with st.spinner("Step 4/8: Aligning ToC sections..."):
                aligned_sections = align_tocs(english_toc, german_toc)
                st.toast(f"Matched {len(aligned_sections)} ToC sections.")
                with st.expander("✅ Matched Sections", expanded=True):
                    for sec in aligned_sections:
                        st.write(f"'{sec['english']['title']}' → '{sec['german']['title']}'")

            with st.spinner("Step 5/8: Aligning content for each section..."):
                progress_bar = st.progress(0, "Aligning sections...")
                for i, section in enumerate(aligned_sections):
                    eng_sec, ger_sec = section['english'], section['german']

                    eng_section_content = [item for item in full_english_content if eng_sec['start_page'] <= item['page'] <= eng_sec['end_page']]
                    ger_section_content = [item for item in full_german_content if ger_sec['start_page'] <= item['page'] <= ger_sec['end_page']]

                    if eng_section_content and ger_section_content:
                        aligned_pairs_section = align_content(eng_section_content, ger_section_content, context_window=1)
                        final_aligned_pairs.extend(aligned_pairs_section)
                        # Store results for debug report
                        section_debug_data[eng_sec['title']] = aligned_pairs_section

                    progress_bar.progress((i + 1) / len(aligned_sections), f"Aligned '{eng_sec['title']}'")
            
            with st.spinner("Step 6/8: Saving alignment and debug reports..."):
                final_aligned_pairs.sort(key=lambda x: (x['english']['page'] if x.get('english') else float('inf')))
                
                alignment_report_path = output_dir / f"alignment_{base_filename}.xlsx"
                save_alignment_report(final_aligned_pairs, alignment_report_path)
                st.toast("Saved Main Alignment Report.")

                debug_report_path = output_dir / f"debug_report_{base_filename}.xlsx"
                save_sectionwise_debug_report(section_debug_data, debug_report_path)
                st.toast("Saved Section-wise Debug Report.")


            with st.spinner("Step 7/8: Evaluating aligned pairs for errors..."):
                st.session_state.evaluation_results = list(run_evaluation_pipeline(final_aligned_pairs))

            with st.spinner("Step 8/8: Saving evaluation report..."):
                if st.session_state.evaluation_results:
                    eval_report_path = output_dir / f"evaluation_{base_filename}.xlsx"
                    save_evaluation_report(st.session_state.evaluation_results, eval_report_path)
                    st.toast("Saved Evaluation Report.")

            st.session_state.analysis_complete = True
            st.success("Analysis pipeline finished successfully!")
            time.sleep(2)
            st.rerun()

        except Exception as e:
            st.session_state.error_message = f"An error occurred: {e}"
            st.exception(e) # Also show traceback in the terminal for debugging
            st.rerun()
        
        finally:
            # --- GUARANTEED CLEANUP ---
            # This block runs whether the try block succeeds or fails
            if eng_temp_path and eng_temp_path.exists():
                os.remove(eng_temp_path)
            if ger_temp_path and ger_temp_path.exists():
                os.remove(ger_temp_path)


    # --- Download Button ---
    st.header("3. Export Results")
    if st.session_state.analysis_complete and st.session_state.evaluation_results:
        excel_data = create_excel_report_in_memory(st.session_state.evaluation_results)
        st.download_button(
            label="📥 Download Evaluation Report",
            data=excel_data,
            file_name=f"Translation_Evaluation_{datetime.now().strftime('%Y-%m-%d')}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )
    else:
        st.markdown("_Report available after analysis._")

# --- Main Display Area ---
st.header("Evaluation Results")

if st.session_state.error_message:
    st.error(st.session_state.error_message, icon="🚨")
elif st.session_state.analysis_complete:
    if not st.session_state.evaluation_results:
        st.success("✅ Analysis complete. No significant errors were found.")
    else:
        display_results(st.session_state.evaluation_results)
else:
    st.info("Upload your PDFs and click 'Run Analysis' to begin.")

