// src/processing/json_parser.py
import json
from pathlib import Path
from typing import List, Dict, Any
import re # <--- NEW IMPORT

import config

# A type alias for our structured content for clarity
ContentItem = Dict[str, Any]

def _convert_table_to_markdown(table_obj: Dict) -> str:
    """Converts an Azure table object into a Markdown string."""
    # ... (function body remains unchanged) ...
    markdown_str = ""
    if not table_obj.get('cells'):
        return ""

    # Create header
    header_cells = [cell for cell in table_obj['cells'] if cell.get('kind') == 'columnHeader']
    if header_cells:
        header_cells.sort(key=lambda x: x['columnIndex'])
        # Handle cells that might span multiple columns
        header_content = []
        for cell in header_cells:
            content = cell.get('content', '').strip()
            col_span = cell.get('columnSpan', 1)
            header_content.extend([content] * col_span)
        
        header_row = "| " + " | ".join(header_content) + " |"
        separator_row = "| " + " | ".join(["---"] * len(header_content)) + " |"
        markdown_str += header_row + "\n" + separator_row + "\n"

    # Create body rows
    body_cells = [cell for cell in table_obj['cells'] if cell.get('kind') is None]
    
    rows = {}
    for cell in body_cells:
        row_idx = cell.get('rowIndex', 0)
        if row_idx not in rows:
            rows[row_idx] = []
        rows[row_idx].append(cell)

    for row_idx in sorted(rows.keys()):
        row_cells = sorted(rows[row_idx], key=lambda x: x.get('columnIndex', 0))
        row_str = "| " + " | ".join([cell.get('content', '').strip() for cell in row_cells]) + " |"
        markdown_str += row_str + "\n"
        
    return markdown_str.strip()


def extract_canonical_toc_headings(full_text: str) -> List[str]:
    """
    Extracts the definite, canonical section headings found in the TOC.
    This directly implements the user's PyMuPDF/regex logic to get the list of keys.
    """
    # Regex patterns provided by the user, modified slightly for robustness:
    # 1. Main sections (A, B, C, D) e.g., 'A _ To Our Investors' (Must capture only up to the first space after the prefix)
    main_title_pattern = re.compile(r"^[A-D] _? (.*)")
    # 2. Numbered sections (e.g., '2 Supervisory Board Report') - Captures the heading text only
    sub_section_pattern = re.compile(r"^\d+ (.*)")
    # 3. All-caps headings (e.g., 'FINANCIAL STATEMENTS') - Captures all caps words followed by non-newline characters
    heading_pattern = re.compile(r"^[A-Z\s]+$")

    canonical_headings = []
    
    # Analyze only the first 5000 characters to capture the TOC, avoiding large text analysis
    toc_text_block = full_text[:5000]

    for line in toc_text_block.split('\n'):
        line = line.strip()
        if not line or len(line) < 5: # Ignore very short lines/noise
            continue

        match = None
        # Check for A/B/C/D sections
        if re.match(r"^[A-D] _", line):
            # Clean the line by stripping everything after the section name (e.g., page numbers, page ranges)
            # Find the index of the first digit (page number) to cut the string
            first_digit_index = next((i for i, char in enumerate(line) if char.isdigit()), len(line))
            
            # Keep only the structural prefix and the section name
            cleaned_line = line[:first_digit_index].strip()
            
            # Strip trailing garbage/page markers that might not be digits
            cleaned_line = cleaned_line.replace('Pages', '').replace('Seiten', '').strip()
            
            # Only accept lines that look like a clean major A/B/C/D heading
            if re.match(r"^[A-D] _ [A-Za-z\s]+$", cleaned_line):
                 match = cleaned_line
                 
        # Check for Numbered Sub-Sections (e.g., 2, 8, 11)
        elif re.match(r"^\d+\s", line):
            # Use the regex to clean out numbers and trailing page numbers/ranges (e.g., "49 Nature of Operations...Pages 49")
            # We assume the heading ends before the page number or the word "Pages/Seiten"
            # In the user's list: "2 Supervisory Board Report", "8 Mandates..."
            parts = line.split()
            if len(parts) > 1 and parts[0].isdigit():
                heading_text = " ".join(parts[1:])
                # Stop at the first occurrence of "Pages" or a page number indicator
                final_heading = heading_text.split('Pages')[0].split('Seiten')[0].strip()
                # Also strip any trailing digits that might be page numbers without the word 'Pages'
                final_heading = re.sub(r'\s*\d+([\s\-\d]+)?$', '', final_heading).strip()
                match = final_heading
                
        # Check for All-Caps Headings (e.g., FINANCIAL STATEMENTS)
        elif heading_pattern.match(line) and len(line) > 5 and ' ' in line:
            match = line
            
        if match and match not in canonical_headings:
            canonical_headings.append(match)
            
    return canonical_headings


def process_document_json(filepath: Path) -> List[ContentItem]:
    """
    Reads and processes an Azure Document Intelligence JSON file,
    now with dedicated handling for tables.
    """
    if not filepath.exists():
        raise FileNotFoundError(f"The file '{filepath}' was not found.")

    with open(filepath, 'r', encoding='utf-8') as f:
        data = json.load(f)

    try:
        analyze_result = data['analyzeResult']
        full_text_content = analyze_result['content']
        raw_paragraphs = analyze_result.get('paragraphs', [])
        pages = analyze_result.get('pages', [])
        raw_tables = analyze_result.get('tables', [])
    except KeyError as e:
        raise ValueError(f"JSON file '{filepath}' is missing expected key: {e}") from e
    
    # --- Step 1: Identify all character offsets belonging to tables to avoid duplication ---
    # ... (rest of Step 1 remains unchanged)
    table_offsets = set()
    for table in raw_tables:
        for span in table.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                table_offsets.add(i)
    
    # Identify all character offsets that are handwritten
    handwritten_offsets = set()
    if 'styles' in analyze_result:
        for style in analyze_result['styles']:
            if style.get('isHandwritten') and style.get('spans'):
                for span in style['spans']:
                    for i in range(span['offset'], span['offset'] + span['length']):
                        handwritten_offsets.add(i)
    
    # Create a quick lookup for page number by span offset
    page_lookup = {}
    for page in pages:
        for span in page.get('spans', []):
            for i in range(span['offset'], span['offset'] + span['length']):
                page_lookup[i] = page.get('pageNumber', 0)

    # --- Step 2: Extract all content, including tables, and sort by position ---
    all_content: List[ContentItem] = []

    # Process PARAGRAPHS
    for p in raw_paragraphs:
        role = p.get('role', 'paragraph')
        if role in config.IGNORED_ROLES or not p.get('spans'):
            continue
        
        offset = p['spans'][0]['offset']
        # If the paragraph is inside a table or is handwritten, SKIP it.
        if offset in table_offsets or offset in handwritten_offsets:
            continue
            
        length = p['spans'][0]['length']
        text = full_text_content[offset : offset + length].strip()
        page_number = page_lookup.get(offset, 0)
        if text:
            all_content.append({'text': text, 'type': role, 'page': page_number, 'offset': offset})
            
    # Process TABLES
    for table in raw_tables:
        if not table.get('spans'):
            continue
        offset = table['spans'][0]['offset']
        page_number = page_lookup.get(offset, 0)
        markdown_table = _convert_table_to_markdown(table)
        if markdown_table:
            all_content.append({'text': markdown_table, 'type': 'table', 'page': page_number, 'offset': offset})

    # Sort all extracted content by its character offset to maintain document order
    all_content.sort(key=lambda x: x['offset'])

    # --- Step 3: Stitch broken paragraphs ---
    final_content: List[ContentItem] = []
    stitched_text = ""
    current_page = 0
    current_type = "paragraph"

    for i, segment in enumerate(all_content):
        # If the current element is a table or a structural heading, finalize the previous stitched text.
        is_standalone = segment['type'] in config.STRUCTURAL_ROLES or segment['type'] == 'table'

        if is_standalone:
            if stitched_text: # Finalize any pending paragraph
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = ""
            final_content.append(segment) # Add the standalone item
            continue

        # This logic handles stitching of regular paragraphs
        if not stitched_text: # Start a new paragraph
            stitched_text = segment['text']
            current_page = segment['page']
            current_type = segment['type']
        else:
            # If previous text ends with punctuation, start a new paragraph
            if stitched_text.endswith(('.', '!', '?', ':', '•')):
                final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
                stitched_text = segment['text']
                current_page = segment['page']
                current_type = segment['type']
            else: # Continue stitching the current paragraph
                stitched_text += f" {segment['text']}"

    # Add the last stitched paragraph if it exists
    if stitched_text:
        final_content.append({'text': stitched_text, 'type': current_type, 'page': current_page})
        
    return final_content

// src/alignment/semantic_aligner.py
# src/alignment/semantic_aligner.py

from typing import List, Dict, Any, Tuple, Optional
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from scipy.optimize import linear_sum_assignment

import config
from src.clients.azure_client import get_embeddings # Correctly import from Azure client

# Type Aliases
ContentItem = Dict[str, Any]
AlignedPair = Dict[str, Any]

def _get_embeddings_with_context(
    texts: List[str],
    content_items: List[ContentItem]
) -> np.ndarray:
    """
    Prepares text with context and gets embeddings from the Azure OpenAI API.
    """
    context_window = 1
    texts_with_context = []
    print(f"Enhancing text with a context window of {context_window}...")
    for i, text in enumerate(texts):
        pre_context = " ".join([content_items[j]['text'] for j in range(max(0, i - context_window), i)])
        post_context = " ".join([content_items[j]['text'] for j in range(i + 1, min(len(texts), i + 1 + context_window))])
        context_text = f"{pre_context} [SEP] {text} [SEP] {post_context}".strip()
        texts_with_context.append(context_text)
    
    # Get embeddings from Azure and convert to numpy array
    embedding_list = get_embeddings(texts_with_context)
    return np.array(embedding_list)

def _calculate_type_matrix(eng_content: List[ContentItem], ger_content: List[ContentItem]) -> np.ndarray:
    """Calculates a matrix rewarding or penalizing based on content type matching."""
    num_eng, num_ger = len(eng_content), len(ger_content)
    type_matrix = np.zeros((num_eng, num_ger))
    for i in range(num_eng):
        for j in range(num_ger):
            if eng_content[i]['type'] == ger_content[j]['type']:
                type_matrix[i, j] = config.TYPE_MATCH_BONUS
            else:
                type_matrix[i, j] = config.TYPE_MISMATCH_PENALTY
    return type_matrix

def _calculate_proximity_matrix(num_eng: int, num_ger: int) -> np.ndarray:
    """Calculates a matrix rewarding based on the relative position in the document."""
    proximity_matrix = np.zeros((num_eng, num_ger))
    for i in range(num_eng):
        for j in range(num_ger):
            norm_pos_eng = i / num_eng if num_eng > 1 else 0
            norm_pos_ger = j / num_ger if num_ger > 1 else 0
            proximity_matrix[i, j] = 1.0 - abs(norm_pos_eng - norm_pos_ger)
    return proximity_matrix

def align_content(
    english_content: List[ContentItem],
    german_content: List[ContentItem],
    generate_debug_report: bool = False
) -> Tuple[List[AlignedPair], Optional[Dict[str, Any]]]:
    """
    Aligns content using the Hungarian algorithm with Azure OpenAI embeddings.

    Returns:
        A tuple containing:
        1. A list of aligned pairs.
        2. A dictionary with all data needed for a debug report (or None if not requested).
    """
    if not english_content or not german_content:
        return [], None

    # Get embeddings for both languages
    english_embeddings = _get_embeddings_with_context(
        [item['text'] for item in english_content], english_content
    )
    german_embeddings = _get_embeddings_with_context(
        [item['text'] for item in german_content], german_content
    )

    # Calculate the three score matrices
    semantic_matrix = cosine_similarity(english_embeddings, german_embeddings)
    type_matrix = _calculate_type_matrix(english_content, german_content)
    proximity_matrix = _calculate_proximity_matrix(len(english_content), len(german_content))

    # Blend the matrices using weights from config
    blended_matrix = (
        (config.W_SEMANTIC * semantic_matrix) +
        (config.W_TYPE * type_matrix) +
        (config.W_PROXIMITY * proximity_matrix)
    )

    debug_data = None
    if generate_debug_report:
        debug_data = {
            'english_content': english_content,
            'german_content': german_content,
            'blended_matrix': blended_matrix,
            'semantic_matrix': semantic_matrix,
            'type_matrix': type_matrix,
            'proximity_matrix': proximity_matrix
        }

    # Find optimal pairs using the Hungarian algorithm
    aligned_pairs: List[AlignedPair] = []
    used_english_indices, used_german_indices = set(), set()
    cost_matrix = -blended_matrix
    row_indices, col_indices = linear_sum_assignment(cost_matrix)

    for eng_idx, ger_idx in zip(row_indices, col_indices):
        score = blended_matrix[eng_idx, ger_idx]
        if score >= config.SIMILARITY_THRESHOLD:
            semantic_score = semantic_matrix[eng_idx, ger_idx]
            aligned_pairs.append({
                "english": english_content[eng_idx],
                "german": german_content[ger_idx],
                "similarity": float(semantic_score)
            })
            used_english_indices.add(eng_idx)
            used_german_indices.add(ger_idx)

    # Add any remaining unmatched items
    for i, item in enumerate(english_content):
        if i not in used_english_indices:
            aligned_pairs.append({"english": item, "german": None, "similarity": 0.0})
    for j, item in enumerate(german_content):
        if j not in used_german_indices:
            aligned_pairs.append({"english": None, "german": item, "similarity": 0.0})
    
    return aligned_pairs, debug_data

// src/alignment/toc_aligner.py
# src/alignment/toc_aligner.py

from typing import List, Dict, Any
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from scipy.optimize import linear_sum_assignment

from src.clients.azure_client import get_embeddings # Import the new function

# Type Aliases for clarity
ToCItem = Dict[str, Any]
AlignedToCPair = Dict[str, Any]

def align_tocs(english_toc: List[ToCItem], german_toc: List[ToCItem]) -> List[AlignedToCPair]:
    """
    Aligns the Table of Contents using Azure OpenAI embeddings.
    """
    if not english_toc or not german_toc:
        return []

    eng_titles = [item['title'] for item in english_toc]
    ger_titles = [item['title'] for item in german_toc]
    
    # Get embeddings from Azure OpenAI API
    english_embeddings_list = get_embeddings(eng_titles)
    german_embeddings_list = get_embeddings(ger_titles)

    # Convert to numpy arrays for calculation
    english_embeddings = np.array(english_embeddings_list)
    german_embeddings = np.array(german_embeddings_list)
    
    # Calculate similarity matrix
    similarity_matrix = cosine_similarity(english_embeddings, german_embeddings)
    
    # Use the Hungarian algorithm to find the optimal assignment
    cost_matrix = -similarity_matrix
    row_indices, col_indices = linear_sum_assignment(cost_matrix)

    aligned_sections: List[AlignedToCPair] = []
    
    print("Matching ToC sections...")
    for eng_idx, ger_idx in zip(row_indices, col_indices):
        score = similarity_matrix[eng_idx, ger_idx]
        if score > 0.4:
            aligned_sections.append({
                'english': english_toc[eng_idx],
                'german': german_toc[ger_idx],
                'similarity': score
            })
            print(f"  - Matched '{english_toc[eng_idx]['title']}' -> '{german_toc[ger_idx]['title']}' (Score: {score:.2f})")

    return aligned_sections

// src/processing/toc_parser.py
# src/processing/toc_parser.py

import re
from pathlib import Path
from typing import List, Dict, Any
import fitz  # PyMuPDF

# A type alias for a structured ToC item
ToCItem = Dict[str, Any]

def get_toc_text_from_pdf(pdf_path: Path, page_num: int = 1) -> str:
    """Extracts raw text from a specific page of a PDF file."""
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found at: {pdf_path}")
    
    try:
        with fitz.open(pdf_path) as doc:
            if page_num < len(doc):
                page = doc.load_page(page_num)
                return page.get_text("text")
            else:
                raise IndexError(f"Page {page_num} does not exist in the document.")
    except Exception as e:
        raise IOError(f"Error opening or reading PDF file '{pdf_path}': {e}") from e

def structure_toc(toc_text: str, page_offset: int = 2) -> List[ToCItem]:
    """
    Parses the raw text of a Table of Contents into a structured list of sections,
    including their titles, start pages, and calculated end pages.

    Args:
        toc_text: The raw text extracted from the ToC page.
        page_offset: The number to add to the page numbers found in the ToC
                     to match the document's actual page numbering (e.g., in the JSON).

    Returns:
        A list of structured ToC items.
    """
    # Regex to find lines that start with a number (page number) followed by text
    section_pattern = re.compile(r"^\s*(\d+)\s+(.*)")
    
    structured_list: List[Dict[str, Any]] = []
    lines = toc_text.split('\n')

    for line in lines:
        line = line.strip()
        match = section_pattern.match(line)
        if match:
            page_number_str, title = match.groups()
            
            # Clean up title by removing any trailing page ranges or extra artifacts
            title = re.sub(r'\s+Pages\s+\d+\s*–\s*\d+', '', title).strip()
            
            if title:  # Ensure the title is not empty after cleaning
                structured_list.append({
                    'title': title,
                    'start_page': int(page_number_str) + page_offset
                })

    if not structured_list:
        return []

    # Calculate the end_page for each section
    for i in range(len(structured_list) - 1):
        # The end page of the current section is one less than the start page of the next
        structured_list[i]['end_page'] = structured_list[i+1]['start_page'] - 1

    # Set the end_page for the very last section to a high number to capture all remaining content
    structured_list[-1]['end_page'] = 999  # Or a more sophisticated document end detection

    return structured_list

// main.py
# main.py

import argparse
import time
import re
from pathlib import Path
from tqdm import tqdm

from dotenv import load_dotenv
load_dotenv()

import config
from src.processing.json_parser import process_document_json
from src.processing.toc_parser import get_toc_text_from_pdf, structure_toc
from src.alignment.toc_aligner import align_tocs
from src.alignment.semantic_aligner import align_content # <-- This is the only function needed from here
from src.reporting.excel_writer import save_alignment_report, save_evaluation_report, save_consolidated_debug_report

def main():
    parser = argparse.ArgumentParser(
        description="Aligns document content section-by-section using a Table of Contents-first approach."
    )
    parser.add_argument("english_pdf", type=str, help="Path to the source English PDF file.")
    parser.add_argument("german_pdf", type=str, help="Path to the source German PDF file.")
    parser.add_argument("english_json", type=str, help="Path to the processed English JSON file.")
    parser.add_argument("german_json", type=str, help="Path to the processed German JSON file.")
    
    parser.add_argument("-o", "--output", type=str, default=None, help="Path for the output alignment Excel file.")
    parser.add_argument("--evaluate", action="store_true", help="Run the AI evaluation pipeline after alignment.")
    parser.add_argument("--debug-report", action="store_true", help="Generate a single detailed score calculation report with a summary and sheets for each section.")
    args = parser.parse_args()

    # --- Setup ---
    eng_pdf_path, ger_pdf_path = Path(args.english_pdf), Path(args.german_pdf)
    eng_json_path, ger_json_path = Path(args.english_json), Path(args.german_json)
    output_dir = Path(config.OUTPUT_DIR)
    output_dir.mkdir(exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")

    print("--- Document Alignment Pipeline Started (ToC-First Approach) ---")
    
    # --- Steps 1, 2, 3 are unchanged ---
    print("Step 1/5: Processing full JSON files...")
    full_english_content = process_document_json(eng_json_path)
    full_german_content = process_document_json(ger_json_path)
    
    print("\nStep 2/5: Extracting and structuring Tables of Contents from PDFs...")
    english_toc = structure_toc(get_toc_text_from_pdf(eng_pdf_path, page_num=1))
    german_toc = structure_toc(get_toc_text_from_pdf(ger_pdf_path, page_num=1))

    print("\nStep 3/5: Aligning ToC sections semantically...")
    aligned_sections = align_tocs(english_toc, german_toc)

    # --- Step 4: Perform Section-by-Section Content Alignment ---
    final_aligned_pairs = []
    all_debug_reports = [] # New list to hold data for the consolidated report
    print("\nStep 4/5: Performing content alignment for each matched section...")
    
    for i, section in enumerate(tqdm(aligned_sections, desc="Aligning Sections"), 1):
        eng_sec = section['english']
        ger_sec = section['german']
        
        eng_section_content = [item for item in full_english_content if eng_sec['start_page'] <= item['page'] <= eng_sec['end_page']]
        ger_section_content = [item for item in full_german_content if ger_sec['start_page'] <= item['page'] <= ger_sec['end_page']]

        if not eng_section_content or not ger_section_content:
            continue
        
        aligned_pairs, debug_data = align_content(
            english_content=eng_section_content,
            german_content=ger_section_content,
            generate_debug_report=args.debug_report
        )
        final_aligned_pairs.extend(aligned_pairs)
        
        if args.debug_report and debug_data:
            first_two_words = "_".join(eng_sec['title'].split()[:2])
            sheet_name = f"{i}_{re.sub(r'[^A-Za-z0-9_]', '', first_two_words)} EN"
            
            all_debug_reports.append({
                'sheet_name': sheet_name,
                'data': debug_data
            })

    final_aligned_pairs.sort(key=lambda x: (x['english']['page'] if x.get('english') else float('inf')))
    print(f"-> Alignment complete. Found {len(final_aligned_pairs)} total pairs.\n")

    # --- Step 5: Write Reports ---
    output_alignment_path = Path(args.output) if args.output else output_dir / f"alignment_report_{timestamp}.xlsx"
    print("Step 5/5: Writing final reports...")
    save_alignment_report(final_aligned_pairs, output_alignment_path)
    print(f"-> Alignment report saved to: {output_alignment_path.resolve()}")

    if args.debug_report:
        debug_report_path = output_dir / f"debug_report_{timestamp}.xlsx"
        save_consolidated_debug_report(all_debug_reports, debug_report_path)
        print(f"-> Consolidated debug report saved to: {debug_report_path.resolve()}\n")

    if args.evaluate:
        print("Running AI evaluation pipeline...")
        from src.evaluation.pipeline import run_evaluation_pipeline
        try:
            evaluation_results = list(run_evaluation_pipeline(final_aligned_pairs))
            if evaluation_results:
                print(f"-> Evaluation complete. Found {len(evaluation_results)} potential errors.")
                output_eval_path = output_dir / f"evaluation_report_{timestamp}.xlsx"
                save_evaluation_report(evaluation_results, output_eval_path)
                print(f"-> Evaluation report saved to: {output_eval_path.resolve()}")
            else:
                print("-> Evaluation complete. No significant errors were found.")
        except Exception as e:
            print(f"\nAn unexpected error occurred during evaluation: {e}")

    print("\n--- Pipeline Finished Successfully ---")

if __name__ == "__main__":
    main()

