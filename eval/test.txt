import { useState } from 'react'; // Removed useRef and useEffect
import { RingLoader } from 'react-spinners';
import { 
  FiFile, FiUploadCloud, FiX, FiCheckCircle, FiAlertTriangle, 
  FiDownload, FiCpu, FiSettings, FiFileText, FiZap 
} from 'react-icons/fi';
import './App.css';

const API_URL = 'http://localhost:8000';

// We no longer need the statusMessages array, the backend will send them.

function App() {
  // --- State for the Form ---
  const [englishFile, setEnglishFile] = useState(null);
  const [germanFile, setGermanFile] = useState(null);
  const [alignmentMode, setAlignmentMode] = useState('Full Document');
  const [tocPageNum, setTocPageNum] = useState(2);

  // --- State for the App Status ---
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [loadingStatus, setLoadingStatus] = useState("Initializing...");
  const [analysisComplete, setAnalysisComplete] = useState(false);

  // --- State for the Results ---
  const [findings, setFindings] = useState([]);
  const [reportBase64, setReportBase64] = useState(null);

  /**
   * Main function to handle the API call
   */
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!englishFile || !germanFile) {
      setError('Please upload both PDF files.');
      return;
    }

    // --- RESET ALL STATES ---
    setIsLoading(true);
    setError(null);
    setFindings([]);
    setReportBase64(null);
    setAnalysisComplete(false);
    setLoadingStatus("Connecting to server..."); // Initial status

    // --- Prepare Form Data ---
    const formData = new FormData();
    formData.append('english_pdf', englishFile);
    formData.append('german_pdf', germanFile);
    formData.append('alignment_mode', alignmentMode);
    formData.append('toc_page_num', tocPageNum);

    try {
      // --- Use Fetch API to handle the streaming POST request ---
      const response = await fetch(`${API_URL}/analyze`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Server error: ${response.status} ${response.statusText}`);
      }

      // --- Prepare to read the stream ---
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = ''; // Buffer for partial messages

      // --- Recursive function to read the stream ---
      const readStream = async () => {
        const { done, value } = await reader.read();

        if (done) {
          // Stream finished
          setIsLoading(false);
          setAnalysisComplete(true);
          return;
        }

        // Decode the chunk (Uint8Array) and add to buffer
        buffer += decoder.decode(value, { stream: true });

        // Process all complete messages (ending in \n\n)
        let boundary = buffer.indexOf('\n\n');
        while (boundary !== -1) {
          const message = buffer.substring(0, boundary);
          buffer = buffer.substring(boundary + 2); // Move buffer past the message
          
          if (message.startsWith('data: ')) {
            const jsonData = message.substring(6); // Get the JSON part
            try {
              const data = JSON.parse(jsonData);

              // --- Handle the message from the backend ---
              if (data.status === 'progress') {
                setLoadingStatus(data.message);
              } 
              else if (data.status === 'complete') {
                setFindings(data.findings || []);
                setReportBase64(data.report_base64);
                setIsLoading(false);
                setAnalysisComplete(true);
                reader.cancel(); // We are done, stop reading
                return;
              }
              else if (data.status === 'error') {
                setError(`Analysis Failed: ${data.message}`);
                setIsLoading(false);
                setAnalysisComplete(true);
                reader.cancel();
                return;
              }
            } catch (jsonError) {
              console.error("Failed to parse JSON from stream:", jsonData, jsonError);
            }
          }
          boundary = buffer.indexOf('\n\n'); // Find next message
        }
        
        // Continue reading the stream
        await readStream();
      };

      // Start reading the stream
      await readStream();

    } catch (err) {
      setError(`Analysis Failed: ${err.message}`);
      setIsLoading(false);
      setAnalysisComplete(true);
    }
    // No finally block needed, loading state is managed by the stream readers
  };

  /**
   * Triggers a download of the Base64 Excel data
   */
  const handleDownload = () => {
    if (!reportBase64) return;
    const link = document.createElement('a');
    link.href = `data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,${reportBase64}`;
    link.download = `Translation_Evaluation_${new Date().toISOString().split('T')[0]}.xlsx`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="app-container">
      <header className="app-header">
        <h1><FiCpu className="header-icon" /> Translation AI Evaluator</h1>
      </header>

      <main className="app-main">
        {/* --- Form and Controls Panel --- */}
        <form onSubmit={handleSubmit} className="control-panel glass-panel">
          
          <div className="panel-section upload-section">
            <h2 className="panel-header">
              <FiUploadCloud /> 1. Upload Documents
            </h2>
            <div className="upload-zones">
              <FileUploadZone
                file={englishFile}
                setFile={setEnglishFile}
                title="English (Source) PDF"
              />
              <FileUploadZone
                file={germanFile}
                setFile={setGermanFile}
                title="German (Translated) PDF"
              />
            </div>
          </div>

          <div className="panel-section config-section">
            <h2 className="panel-header">
              <FiSettings /> 2. Configure Analysis
            </h2>
            <div className="config-grid">
              <div className="form-group segment-group">
                <label>Alignment Mode</label>
                <div className="segmented-control">
                  <button
                    type="button"
                    className={`segment-option ${alignmentMode === 'ToC-Based' ? 'active' : ''}`}
                    onClick={() => setAlignmentMode('ToC-Based')}
                  >
                    ToC-Based
                  </button>
                  <button
                    type="button"
                    className={`segment-option ${alignmentMode === 'Full Document' ? 'active' : ''}`}
                    onClick={() => setAlignmentMode('Full Document')}
                  >
                    Full Document
                  </button>
                </div>
              </div>
              
              {alignmentMode === 'ToC-Based' && (
                <div className="form-group toc-group">
                  <label htmlFor="tocPageNum">ToC Page Number</label>
                  <input
                    id="tocPageNum"
                    type="number"
                    value={tocPageNum}
                    onChange={(e) => setTocPageNum(parseInt(e.target.value, 10))}
                    min="1"
                    step="1"
                  />
                </div>
              )}
            </div>
          </div>

          <div className="panel-section run-section">
            <h2 className="panel-header">
              <FiZap /> 3. Execute
            </h2>
            <div className="run-buttons">
              <button
                type="submit"
                className="btn btn-primary"
                disabled={isLoading || !englishFile || !germanFile}
              >
                {isLoading ? (
                  <RingLoader size={20} color={"#fff"} speedMultiplier={1} />
                ) : (
                  'Run Analysis'
                )}
                {isLoading && <span>Analyzing...</span>}
              </button>
              
              {reportBase64 && !isLoading && (
                <button type="button" onClick={handleDownload} className="btn btn-secondary">
                  <FiDownload />
                  <span>Download Report</span>
                </button>
              )}
            </div>
          </div>
        </form>

        {/* --- Results Panel --- */}
        <section className="results-panel">
          <h2 className="panel-header">Evaluation Results</h2>
          <div className="results-content glass-panel">
            <StatusDisplay
              isLoading={isLoading}
              error={error}
              findingsCount={findings.length}
              loadingStatus={loadingStatus}
              analysisComplete={analysisComplete} 
            />
            
            {findings.length > 0 && !isLoading && (
              <div className="findings-list">
                {findings.map((finding, index) => (
                  <FindingCard key={index} finding={finding} />
                ))}
              </div>
            )}
          </div>
        </section>
      </main>
    </div>
  );
}

// --- Helper Component: FileUploadZone ---
// (Unchanged)
function FileUploadZone({ file, setFile, title }) {
  const [isDragging, setIsDragging] = useState(false);
  const inputId = `file-input-${title.replace(' ', '-')}`;

  const handleDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
  const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
  const handleDrop = (e) => {
    e.preventDefault();
    setIsDragging(false);
    const droppedFile = e.dataTransfer.files[0];
    if (droppedFile && droppedFile.type === "application/pdf") setFile(droppedFile);
  };
  const handleFileChange = (e) => {
    const selectedFile = e.target.files[0];
    if (selectedFile) setFile(selectedFile);
  };

  if (file) {
    return (
      <div className="file-drop-zone file-selected">
        <FiFileText className="file-icon" />
        <span className="file-name">{file.name}</span>
        <button type="button" className="remove-file-btn" onClick={() => setFile(null)}>
          <FiX />
        </button>
      </div>
    );
  }
  return (
    <label
      htmlFor={inputId}
      className={`file-drop-zone ${isDragging ? 'dragging' : ''}`}
      onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}
    >
      <input type="file" id={inputId} accept="application/pdf" onChange={handleFileChange} className="hidden-file-input" />
      <FiUploadCloud className="upload-icon" />
      <span className="upload-title">{title}</span>
      <span className="upload-text">Drag & drop PDF, or click to browse</span>
    </label>
  );
}

// --- Helper Component: StatusDisplay ---
// (Unchanged)
function StatusDisplay({ isLoading, error, findingsCount, loadingStatus, analysisComplete }) {
  if (isLoading) {
    return (
      <div className="status-display loading">
        <RingLoader color={"#8884d8"} size={60} />
        <h3>Analyzing Documents...</h3>
        <p className="loading-status-text">{loadingStatus}</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="status-display error">
        <FiAlertTriangle className="status-icon" />
        <h3>Analysis Failed</h3>
        <p>{error}</p>
      </div>
    );
  }

  if (analysisComplete && findingsCount === 0) {
    return (
      <div className="status-display success"> 
        <FiCheckCircle className="status-icon" />
        <h3>Analysis Complete</h3>
        <p>No significant issues found. Good to go!</p>
      </div>
    );
  }

  if (!analysisComplete && findingsCount === 0) { 
    return (
      <div className="status-display empty">
        <FiCheckCircle className="status-icon" />
        <h3>Ready to Analyze</h3>
        <p>Upload your documents and click "Run Analysis" to see the results.</p>
      </div>
    );
  }

  return null;
}

// --- Helper Component: FindingCard ---
// (Unchanged)
function FindingCard({ finding }) {
  const {
    page, type, suggestion, english_text, german_text, original_phrase, translated_phrase,
  } = finding;
  
  const typeClass = type.toLowerCase().replace(' ', '-');

  return (
    <div className="finding-card glass-panel">
      <div className="card-header">
        <span className={`card-badge ${typeClass}`}>{type}</span>
        <span className="card-page">Page: {page || 'N/A'}</span>
      </div>

      {(original_phrase || translated_phrase) && (
        <div className="card-section focus-section">
          <h4>Key Discrepancy</h4>
          <div className="text-pair">
            <div className="text-block">
              <strong>English Phrase</strong>
              <p className="highlight-en">{original_phrase || 'N/A'}</p>
            </div>
            <div className="text-block">
              <strong>German Phrase</strong>
              <p className="highlight-de">{translated_phrase || 'N/A'}</p>
            </div>
          </div>
        </div>
      )}

      <div className="card-section context-section">
        <h4>Full Context</h4>
        <div className="text-pair">
          <div className="text-block">
            <strong>English Text</strong>
            <blockquote>{english_text}</blockquote>
          </div>
          <div className="text-block">
            <strong>German Text</strong>
            <blockquote>{german_text}</blockquote>
          </div>
        </div>
      </div>

      <div className="card-section suggestion-section">
        <strong><FiZap /> Suggestion:</strong>
        <p>{suggestion}</p>
      </div>
    </div>
  );
}

export default App;
