' ===== CONFIG =====
Const ENABLE_DEFRAG As Boolean = True
Const DEFRAG_MIN_CHARS As Long = 140
Private DEFRAG_SENT_ENDS As String ' <<< CHANGED: Was Const, see InitDefragChars

Const PENALTY_1x2 As Double = 12#
Const PENALTY_2x1 As Double = 12#
Const PENALTY_2x2 As Double = 20#
Const PENALTY_SKIP_BASE As Double = 120#
Const PENALTY_SKIP_PER_CHAR As Double = 0.4

' Common boilerplate to drop after cleaning
Private BLACKLIST As Variant
Private Sub InitBlacklist()
    BLACKLIST = Array( _
        "Internal", _
        "Annual Report 2024", _
        "Allianz Group", _
        "Geschäftsbericht 2024", _
        "Allianz Konzern", _
        "SUPERVISORY BOARD REPORT", _
        "BERICHT DES AUFSICHTSRATS", _
        "_ To our Investors _", _
        "_ An unsere Aktionärinnen und Aktionäre _" _
    )
End Sub

' <<< ADDED: New sub to handle special characters safely
Private Sub InitDefragChars()
    ' Build the string using character codes to avoid syntax errors
    ' ChrW(8221) = ” (smart quote)
    ' ChrW(187)  = » (chevron)
    DEFRAG_SENT_ENDS = ".?!:;)]" & ChrW(8221) & ChrW(187) & ChrW(187)
End Sub

' ========= UTILITIES =========
Private Function CleanText(ByVal s As String) As String
    Dim t As String
    t = s
    ' normalize spaces and line artifacts
    t = Replace(t, ChrW(160), " ")   ' NBSP -> space
    t = Replace(t, vbTab, " ")
    t = Replace(t, Chr(11), " ")     ' manual line (rare in Ranges)
    t = Replace(t, ChrW(173), "")    ' soft hyphen
    t = Replace(t, Chr(7), "")       ' bell (rare)
    ' collapse whitespace
    Do While InStr(t, "  ") > 0: t = Replace(t, "  ", " "): Loop
    CleanText = Trim$(t)
End Function

Private Function IsBlacklisted(ByVal s As String) As Boolean
    Dim i As Long, key As String
    key = LCase$(s)
    For i = LBound(BLACKLIST) To UBound(BLACKLIST)
        If InStr(1, key, LCase$(BLACKLIST(i)), vbTextCompare) > 0 Then
            IsBlacklisted = True
            Exit Function
        End If
    Next
End Function

Private Function ParaLen(ByVal s As String) As Long
    ParaLen = Len(Replace(Replace(s, " ", ""), vbTab, ""))
End Function

'
'
' <<< --- FIX #1 IS HERE --- >>>
' The function MUST return As Double
'
Private Function SumLen(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As Double
    Dim i As Long, N As Double
    For i = i1 To i2: N = N + ParaLen(arr(i)): Next
    SumLen = N
End Function

Private Function JoinRange(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As String
    Dim i As Long, t As String
    For i = i1 To i2
        If Len(arr(i)) > 0 Then
            If Len(t) > 0 Then
                t = t & vbCrLf & arr(i)
            Else
                t = arr(i)
            End If
        End If
    Next
    JoinRange = t
End Function

Private Function EndsWithAny(ByVal s As String, ByVal chars As String) As Boolean
    If Len(s) = 0 Then Exit Function
    EndsWithAny = InStr(1, chars, Right$(s, 1), vbBinaryCompare) > 0
End Function

' ---------- PDF → DOCX hygiene ----------
Private Sub StripHeadersAndFooters(doc As Document)
    Dim sec As Section
    For Each sec In doc.Sections
        On Error Resume Next
        sec.Headers(wdHeaderFooterPrimary).Range.Delete
        sec.Headers(wdHeaderFooterFirstPage).Range.Delete
        sec.Headers(wdHeaderFooterEvenPages).Range.Delete
        sec.Footers(wdHeaderFooterPrimary).Range.Delete
        sec.Footers(wdHeaderFooterFirstPage).Range.Delete
        sec.Footers(wdHeaderFooterEvenPages).Range.Delete
        On Error GoTo 0
    Next sec
End Sub

Private Sub ReplaceAll(rng As Range, findTxt As String, replTxt As String, Optional useWildcards As Boolean = False)
    With rng.Find
        .ClearFormatting: .Replacement.ClearFormatting
        .Text = findTxt
        .Replacement.Text = replTxt
        .Forward = True
        .Wrap = wdFindStop
        .Format = False
        .MatchWildcards = useWildcards
        .Execute Replace:=wdReplaceAll
    End With
End Sub

Private Sub PreprocessDoc(doc As Document)
    ' Work on a temp Range (whole doc)
    Dim R As Range: Set R = doc.Content

    ' 1) Remove headers/footers (page numbers, ribbons)
    StripHeadersAndFooters doc

    ' 2) De-hyphenate splits across paragraph or manual line breaks
    '    "-^13" or "-^l" → "" (join word halves)
    ReplaceAll R, "-^13", ""
    ReplaceAll R, "-^l", ""

    ' 3) Convert manual line breaks (^l) to space to restore sentences
    ReplaceAll R, "^l", " "

    ' 4) Convert page breaks (^m) and section breaks (^b) to space
    ReplaceAll R, "^m", " "
    ReplaceAll R, "^b", " "

    ' 5) Remove soft hyphens and odd control chars (defensive)
    ReplaceAll R, ChrW(173), ""      ' soft hyphen, if any remain

    ' 6) Collapse multiple spaces
    Do
        Dim cntBefore As Long
        cntBefore = Len(R.Text)
        ReplaceAll R, "  ", " "
        If Len(R.Text) = cntBefore Then Exit Do
    Loop
End Sub

Private Sub CollectParagraphs(doc As Document, ByRef texts() As String)
    InitBlacklist
    InitDefragChars  ' <<< ADDED: Initialize the special characters string

    ' Ensure doc is cleaned BEFORE collecting
    PreprocessDoc doc

    Dim p As Paragraph, tmp As New Collection, s As String
    For Each p In doc.Paragraphs
        s = CleanText(p.Range.Text)
        ' Skip empty, very short noise, or blacklisted boilerplate
        If Len(s) >= 3 Then
            If Not IsBlacklisted(s) Then
                ' Also skip pure page labels like just a page number
                If Not s Like "#" Then
                If Not s Like "##" Then
                If Not s Like "*" Then
                    tmp.Add s
                End If
                End If
                End If
            End If
        End If
    Next

    If tmp.Count = 0 Then
        ReDim texts(1 To 1): texts(1) = ""
        Exit Sub
    End If
    ReDim texts(1 To tmp.Count)
    Dim i As Long
    For i = 1 To tmp.Count: texts(i) = tmp(i): Next
End Sub

Private Sub DefragmentParas(ByRef arr() As String)
    If Not ENABLE_DEFRAG Then Exit Sub
    If UBound(arr) < 2 Then Exit Sub
    Dim outCol As New Collection, i As Long, buf As String
    For i = LBound(arr) To UBound(arr)
        If Len(buf) = 0 Then
            buf = arr(i)
        Else
            ' join with a space since PreprocessDoc removed in-line breaks
            buf = buf & " " & arr(i)
        End If
        Dim enough As Boolean
        enough = (ParaLen(buf) >= DEFRAG_MIN_CHARS) Or EndsWithAny(buf, DEFRAG_SENT_ENDS)
        If enough Then outCol.Add Trim$(buf): buf = ""
    Next
    If Len(buf) > 0 Then outCol.Add Trim$(buf)
    ReDim arr(1 To outCol.Count)
    For i = 1 To outCol.Count: arr(i) = outCol(i): Next
End Sub

Private Function BrowseForFile(prompt As String) As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = prompt
        .Filters.Clear
        .Filters.Add "PDF Files", "*.pdf"
        .AllowMultiSelect = False
        If .Show <> -1 Then Exit Function
        BrowseForFile = .SelectedItems(1)
    End With
End Function

Private Function ConvertPdfToDocx(pdfPath As String) As String
    Dim doc As Document, docxPath As String
    docxPath = Replace(LCase$(pdfPath), ".pdf", ".docx")
    Set doc = Documents.Open(FileName:=pdfPath, ConfirmConversions:=False, ReadOnly:=False, AddToRecentFiles:=False)
    ' Save to docx and close
    doc.SaveAs2 FileName:=docxPath, FileFormat:=wdFormatXMLDocument
    doc.Close SaveChanges:=False
    ConvertPdfToDocx = docxPath
End Function

' ========= MAIN =========
Public Sub AlignTranslatedParagraphs_AutoPick()
    Dim enPDF As String, dePDF As String
    enPDF = BrowseForFile("Select the FIRST PDF file (e.g., English):")
    If enPDF = "" Then MsgBox "No file selected. Operation cancelled.", vbExclamation: Exit Sub

    dePDF = BrowseForFile("Select the SECOND PDF file (e.g., German):")
    If dePDF = "" Then MsgBox "No file selected. Operation cancelled.", vbExclamation: Exit Sub

    MsgBox "Selected files:" & vbCrLf & "First: " & enPDF & vbCrLf & "Second: " & dePDF, vbInformation

    ' Convert PDFs
    Dim enDocx As String, deDocx As String
    enDocx = ConvertPdfToDocx(enPDF)
    deDocx = ConvertPdfToDocx(dePDF)
    MsgBox "Converted to DOCX successfully." & vbCrLf & enDocx & vbCrLf & deDocx, vbInformation

    ' Open (ReadOnly prevents accidental edits)
    Dim enDoc As Document, deDoc As Document
    Set enDoc = Documents.Open(enDocx, ReadOnly:=False, AddToRecentFiles:=False)
    Set deDoc = Documents.Open(deDocx, ReadOnly:=False, AddToRecentFiles:=False)

    ' --- CRITICAL: clean imported DOCX before collecting paragraphs ---
    PreprocessDoc enDoc
    PreprocessDoc deDoc

    ' Paragraphs
    Dim EN() As String, DE() As String
    CollectParagraphs enDoc, EN
    CollectParagraphs deDoc, DE
    DefragmentParas EN: DefragmentParas DE

    ' Ratio
    Dim i As Long, sumEN As Double, sumDE As Double
    For i = LBound(EN) To UBound(EN): sumEN = sumEN + ParaLen(EN(i)): Next
    For i = LBound(DE) To UBound(DE): sumDE = sumDE + ParaLen(DE(i)): Next
    Dim r As Double: r = IIf(sumEN > 0, CDbl(sumDE) / CDbl(sumEN), 1#)

    ' DP arrays
    Dim N As Long, M As Long: N = UBound(EN): M = UBound(DE)
    Dim cost() As Double, backA() As Integer, backI() As Long, backJ() As Long
    ReDim cost(0 To N, 0 To M): ReDim backA(0 To N, 0 To M)
    ReDim backI(0 To N, 0 To M): ReDim backJ(0 To N, 0 To M)
    Dim INF As Double: INF = 1E+30
    Dim j As Long
    For i = 0 To N: For j = 0 To M: cost(i, j) = INF: Next j: Next i
    cost(0, 0) = 0

    Dim c As Double
    For i = 0 To N
        For j = 0 To M
            If cost(i, j) < INF Then
                If i + 1 <= N And j + 1 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 1, r, 0#)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 1, cost(i, j) + c, 1, i, j
                End If
                If i + 1 <= N And j + 2 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 2, r, PENALTY_1x2)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 2, cost(i, j) + c, 2, i, j
                End If
                If i + 2 <= N And j + 1 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 2, j + 1, j + 1, r, PENALTY_2x1)
                    UpdateCell cost, backA, backI, backJ, i + 2, j + 1, cost(i, j) + c, 3, i, j
                End If
                If i + 1 <= N Then
                    c = PENALTY_SKIP_BASE + PENALTY_SKIP_PER_CHAR * ParaLen(EN(i + 1))
                    UpdateCell cost, backA, backI, backJ, i + 1, j, cost(i, j) + c, 5, i, j
                End If
                If j + 1 <= M Then
                    c = PENALTY_SKIP_BASE + PENALTY_SKIP_PER_CHAR * ParaLen(DE(j + 1))
                    UpdateCell cost, backA, backI, backJ, i, j + 1, cost(i, j) + c, 6, i, j
                End If
            End If
        Next j
    Next i

    ' Backtrack
    Dim pairs As New Collection, i1 As Long, j1 As Long
    i1 = N: j1 = M
    Do While Not (i1 = 0 And j1 = 0)
        Dim a As Integer, pi As Long, pj As Long, rec As Variant
        a = backA(i1, j1): pi = backI(i1, j1): pj = backJ(i1, j1)
        rec = Array(a, pi + 1, i1, pj + 1, j1)
        pairs.Add rec
        i1 = pi: j1 = pj
    Loop

    ' Output table
    Dim outDoc As Document: Set outDoc = Documents.Add
    Dim rows As Long: rows = pairs.Count + 1
    Dim tbl As Table
    Set tbl = outDoc.Tables.Add(Range:=outDoc.Range(0, 0), NumRows:=rows, NumColumns:=3)
    tbl.Style = "Table Grid"
    tbl.Cell(1, 1).Range.Text = "English"
    tbl.Cell(1, 2).Range.Text = "German"
    tbl.Cell(1, 3).Range.Text = "Mapping"

    Dim k As Long, rcd As Variant, enFrom As Long, enTo As Long, deFrom As Long, deTo As Long
    For k = pairs.Count To 1 Step -1
        rcd = pairs(k)
        a = rcd(0): enFrom = rcd(1): enTo = rcd(2): deFrom = rcd(3): deTo = rcd(4)
        Dim rowIx As Long: rowIx = pairs.Count - k + 2
        tbl.Cell(rowIx, 1).Range.Text = JoinRange(EN, enFrom, enTo)
        tbl.Cell(rowIx, 2).Range.Text = JoinRange(DE, deFrom, deTo)
        tbl.Cell(rowIx, 3).Range.Text = enFrom & "-" & enTo & " ? " & deFrom & "-" & deTo
    Next

    tbl.AutoFitBehavior wdAutoFitContent
    tbl.AutoFitBehavior wdAutoFitWindow

    ' Close source docs (we modified them during preprocess, save in-place docx)
    enDoc.Close SaveChanges:=True
    deDoc.Close SaveChanges:=True

    MsgBox "Alignment complete. Clean paragraphs and mapping table are ready.", vbInformation
End Sub

'
'
' <<< --- FIX #2 IS HERE --- >>>
' The variables MUST be As Double to hold the result from SumLen
'
Private Function AlignCost(EN() As String, DE() As String, ei1 As Long, ei2 As Long, dj1 As Long, dj2 As Long, ratio As Double, penalty As Double) As Double
    Dim lenEN As Double: lenEN = SumLen(EN, ei1, ei2)
    Dim lenDE As Double: lenDE = SumLen(DE, dj1, dj2)
    Dim dev As Double: dev = Abs(lenDE - lenEN * ratio)
    AlignCost = dev ^ 0.9 + penalty
End Function

Private Sub UpdateCell(ByRef cost() As Double, ByRef backA() As Integer, ByRef backI() As Long, ByRef backJ() As Long, ni As Long, nj As Long, newCost As Double, action As Integer, pi As Long, pj As Long)
    If newCost < cost(ni, nj) Then
        cost(ni, nj) = newCost
        backA(ni, nj) = action
        backI(ni, nj) = pi
        backJ(ni, nj) = pj
    End If
End Sub
