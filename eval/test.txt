from typing import List, Dict, Any, Tuple

# Type Alias for clarity
ContentItem = Dict[str, Any]
HeadingPair = Tuple[ContentItem, ContentItem]
AlignedPair = Dict[str, Any] # The final output format for the evaluation pipeline

def _find_content_between(
    start_item: ContentItem, 
    end_item: ContentItem, 
    all_content: List[ContentItem]
) -> str:
    """
    Finds and concatenates all content items between two items,
    based on their character offsets.
    """
    start_offset = start_item['offset']
    end_offset = end_item['offset']
    
    # We want content *after* the start heading and *before* the end heading
    content_blocks = [
        item['text'] for item in all_content
        if start_offset < item['offset'] < end_offset
    ]
    
    return "\n\n".join(content_blocks)

def create_section_pairs(
    validated_heading_pairs: List[HeadingPair],
    full_english_content: List[ContentItem],
    full_german_content: List[ContentItem]
) -> List[AlignedPair]:
    """
    Main orchestration function for Phase 2:
    Uses the validated heading pairs as 'anchors' to extract
    all content *between* them.
    """
    if not validated_heading_pairs:
        return []

    print(f"Creating content sections from {len(validated_heading_pairs)} validated heading pairs...")
    
    final_aligned_pairs: List[AlignedPair] = []
    
    # Iterate through all consecutive pairs of headings
    for i in range(len(validated_heading_pairs) - 1):
        # Current pair (A)
        eng_heading_A, ger_heading_A = validated_heading_pairs[i]
        
        # Next pair (B)
        eng_heading_B, ger_heading_B = validated_heading_pairs[i+1]
        
        # Extract content between A and B for English
        eng_section_text = _find_content_between(
            eng_heading_A, 
            eng_heading_B, 
            full_english_content
        )
        
        # Extract content between A and B for German
        ger_section_text = _find_content_between(
            ger_heading_A, 
            ger_heading_B, 
            full_german_content
        )
        
        # --- MODIFICATION ---
        # The 'if eng_section_text or ger_section_text:' check has been removed.
        # We now append ALL sections, even if both are empty.
        
        final_aligned_pairs.append({
            "english": {
                "text": eng_section_text,
                "type": "section",
                "page": eng_heading_A['page'] # Use start heading page as reference
            },
            "german": {
                "text": ger_section_text,
                "type": "section",
                "page": ger_heading_A['page']
            },
            "similarity": 0.0, # Not applicable in this model
            "margin_score": 0.0 # Not applicable in this model
        })

    # Note: We currently don't process content *after* the last validated heading.
    
    # This number should now be (len(validated_heading_pairs) - 1)
    print(f"Created {len(final_aligned_pairs)} final section pairs for evaluation.")
    return final_aligned_pairs
