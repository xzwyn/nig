Option Explicit

'==================== CONFIG ====================
Private Const ENABLE_DEFRAG As Boolean = True
Private Const DEFRAG_MIN_CHARS As Long = 140
' REFINED: Added straight quotes and guillemets for broader language support
Private Const DEFRAG_SENT_ENDS As String = ".?!:;)""]”’'" & "«»"

Private Const PENALTY_1x2 As Double = 12#
Private Const PENALTY_2x1 As Double = 12#
Private Const PENALTY_2x2 As Double = 22#
Private Const PENALTY_SKIP_BASE As Double = 120#
Private Const PENALTY_SKIP_PER_CHAR As Double = 0.35

Private Const REPEAT_LINE_MAX_LEN As Long = 70      ' candidates for running headers/footers
Private Const REPEAT_MIN_COUNT As Long = 3          ' drop if appears >=3 times

' REFINED: Defined as a module-level constant, initialized once.
Private Const SOFT_HYPHEN As String = ChrW(&HAD)    ' U+00AD

' REFINED: Module-level object for performance. Created once.
Private re As Object

'==================== UTILITIES ====================
Private Function RxTest(ByVal text As String, ByVal pattern As String) As Boolean
    ' REFINED: Creates the RegExp object only once for the entire session.
    If re Is Nothing Then
        Set re = CreateObject("VBScript.RegExp")
        With re
            .Global = False
            .Multiline = False
            .IgnoreCase = True
        End With
    End If
    
    re.pattern = pattern
    On Error Resume Next
    RxTest = re.Test(text)
End Function

Private Function CleanText(ByVal s As String) As String
    Dim t As String
    t = s
    ' Normalize whitespace & control
    t = Replace(t, ChrW(160), " ")
    t = Replace(t, SOFT_HYPHEN, "")                  ' strip soft hyphen from PDF reflow
    t = Replace(t, vbTab, " ")
    t = Replace(t, Chr(11), " ")
    t = Replace(t, Chr(7), "")
    
    ' Common PDF artifacts at line starts
    t = Trim$(t)
    If Left$(t, 2) = "/ " Then t = Mid$(t, 3)
    If Left$(t, 1) = "/" Then t = Mid$(t, 2)

    ' Normalize dashes (en/em) to hyphen for stable counting
    t = Replace(t, "–", "-")
    t = Replace(t, "—", "-")
    
    ' REFINED: Hyphenation healing (now includes vbCrLf)
    t = Replace(t, "- " & vbCrLf, "")
    t = Replace(t, "-" & vbCrLf, "")
    t = Replace(t, "- " & vbCr, "")
    t = Replace(t, "-" & vbCr, "")
    t = Replace(t, "- " & vbLf, "")
    t = Replace(t, "-" & vbLf, "")

    ' Squash CR/LF to spaces
    t = Replace(t, vbCr, " ")
    t = Replace(t, vbLf, " ")
    
    ' Squash multiple spaces
    Do While InStr(t, "  ") > 0
        t = Replace(t, "  ", " ")
    Loop
    CleanText = Trim$(t)
End Function

Private Function ParaLen(ByVal s As String) As Long
    ParaLen = Len(Replace(Replace(s, " ", ""), vbTab, ""))
End Function

Private Function SumLen(arr() As String, ByVal i1 As Long, ByVal i2 As Long) As Long
    Dim i As Long, n As Long
    For i = i1 To i2: n = n + ParaLen(arr(i)): Next
    SumLen = n
End Function

Private Function JoinRange(arr() AsString, ByVal i1 As Long, ByVal i2 As Long) As String
    Dim i As Long, t As String
    For i = i1 To i2
        If Len(arr(i)) > 0 Then
            If Len(t) > 0 Then t = t & vbCrLf & arr(i) Else t = arr(i)
        End If
    Next
    JoinRange = t
End Function

Private Function EndsWithAny(ByVal s As String, ByVal chars As String) As Boolean
    If Len(s) = 0 Then EndsWithAny = False: Exit Function
    EndsWithAny = InStr(1, chars, Right$(s, 1), vbBinaryCompare) > 0
End Function

Private Function LooksLikeTitleCase(ByVal s As String) As Boolean
    Dim words() As String, i As Long, w As String, titled As Long, total As Long
    words = Split(s, " ")
    total = 0: titled = 0
    For i = LBound(words) To UBound(words)
        w = Trim$(words(i))
        If Len(w) > 0 Then
            total = total + 1
            If Mid$(w, 1, 1) = UCase$(Mid$(w, 1, 1)) Then titled = titled + 1
        End If
    Next
    ' Tolerate a stopword
    LooksLikeTitleCase = (total >= 2 And titled >= total - 1)
End Function

Private Sub CountShortLines(ByRef arr() As String, ByRef drop As Object)
    ' Builds frequency of short lines and flags those appearing >= REPEAT_MIN_COUNT
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    Dim i As Long, key As String, k As Variant
    For i = LBound(arr) To UBound(arr)
        key = arr(i)
        If Len(key) > 0 And Len(key) <= REPEAT_LINE_MAX_LEN Then
            If dict.Exists(key) Then
                dict(key) = CLng(dict(key)) + 1
            Else
                dict.Add key, 1
            End If
        End If
    Next i
    Set drop = CreateObject("Scripting.Dictionary")
    For Each k In dict.Keys
        If CLng(dict(k)) >= REPEAT_MIN_COUNT Then drop.Add k, True
    Next k
End Sub


Private Sub CollectParagraphs(doc As Document, ByRef texts() As String)
    Dim p As Object, tmp As New Collection, s As String, i As Long
    For Each p In doc.Paragraphs
        s = CleanText(p.Range.Text)
        If Len(s) > 0 Then tmp.Add s
    Next p
    If tmp.Count = 0 Then
        ReDim texts(1 To 1): texts(1) = ""
    Else
        ReDim texts(1 To tmp.Count)
        For i = 1 To tmp.Count: texts(i) = tmp(i): Next i
    End If
End Sub

Private Sub DropRepeatingShortLines(ByRef arr() As String)
    Dim toDrop As Object: Call CountShortLines(arr, toDrop)
    If toDrop Is Nothing Then Exit Sub
    If toDrop.Count = 0 Then Exit Sub
    
    Dim outCol As New Collection, i As Long, s As String
    For i = LBound(arr) To UBound(arr)
        s = arr(i)
        If Not (Len(s) <= REPEAT_LINE_MAX_LEN And toDrop.Exists(s)) Then
            outCol.Add s
        End If
    Next
    If outCol.Count = 0 Then
        ReDim arr(1 To 1): arr(1) = ""
        Exit Sub
    End If
    ReDim arr(1 To outCol.Count)
    For i = 1 To outCol.Count: arr(i) = outCol(i): Next
End Sub

Private Sub DefragmentParas(ByRef arr() As String)
    If Not ENABLE_DEFRAG Then Exit Sub
    If UBound(arr) < 2 Then Exit Sub
    Dim outCol As New Collection, i As Long, buf As String, enough As Boolean, s As String, isHeading As Boolean
    For i = LBound(arr) To UBound(arr)
        s = arr(i)
        ' Heuristic for headings
        isHeading = (ParaLen(s) < 40) And (s = UCase$(s) Or LooksLikeTitleCase(s))
        If isHeading Then
            ' Flush buffer before adding heading
            If Len(buf) > 0 Then outCol.Add Trim$(buf): buf = ""
            outCol.Add s ' Add heading as its own item
        Else
            ' Append to buffer
            If Len(buf) = 0 Then buf = s Else buf = buf & " " & s
            enough = (ParaLen(buf) >= DEFRAG_MIN_CHARS) Or EndsWithAny(buf, DEFRAG_SENT_ENDS)
            If enough Then outCol.Add Trim$(buf): buf = ""
        End If
    Next
    ' Flush final buffer
    If Len(buf) > 0 Then outCol.Add Trim$(buf)
    
    ReDim arr(1 To outCol.Count)
    For i = 1 To outCol.Count: arr(i) = outCol(i): Next
End Sub

Private Function AlignCost(EN() As String, DE() As String, ei1 As Long, ei2 As Long, dj1 As Long, dj2 As Long, ratio As Double, penalty As Double) As Double
    Dim lenEN As Long: lenEN = SumLen(EN, ei1, ei2)
    Dim lenDE As Long: lenDE = SumLen(DE, dj1, dj2)
    If lenEN = 0 And lenDE = 0 Then AlignCost = penalty: Exit Function
    ' Length mismatch cost (use exponent < 1 to soften outliers)
    Dim dev As Double: dev = Abs(lenDE - lenEN * ratio)
    AlignCost = dev ^ 0.9 + penalty
End Function

Private Sub UpdateCell(ByRef cost() As Double, ByRef backA() As Integer, ByRef backI() As Long, ByRef backJ() As Long, _
                       ni As Long, nj As Long, newCost As Double, action As Integer, pi As Long, pj As Long)
    If newCost < cost(ni, nj) Then
        cost(ni, nj) = newCost
        backA(ni, nj) = action
        backI(ni, nj) = pi
        backJ(ni, nj) = pj
    End If
End Sub

Private Function BrowseForFile(prompt As String, Optional pattern As String = "*.pdf;*.docx") As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = prompt
        .Filters.Clear
        .Filters.Add "Docs (PDF/DOCX)", pattern
        .AllowMultiSelect = False
        If .Show <> -1 Then Exit Function
        BrowseForFile = .SelectedItems(1)
    End With
End Function

Private Function OpenAsDocx(path As String) As Document
    If LCase$(Right$(path, 5)) = ".docx" Then
        Set OpenAsDocx = Documents.Open(path, ReadOnly:=True)
    Else
        Set OpenAsDocx = Documents.Open(FileName:=path, ConfirmConversions:=False, ReadOnly:=True)
    End If
End Function

Private Sub ColorRow(ByVal r As Row, ByVal action As Integer)
    ' REFINED: Colors the entire row's background for better readability
    '          Uses Shading instead of Highlight, which is cleaner
    On Error Resume Next
    Dim c As Cell, clr As WdColor
    
    Select Case action
        Case 1 ' 1x1
            clr = wdColorAutomatic ' No color
        Case 2, 3 ' 1x2 or 2x1
            clr = wdColorYellow
        Case 4 ' 2x2
            clr = wdColorTurquoise
        Case 5, 6 ' skips
            clr = wdColorBrightGreen
        Case Else
            clr = wdColorAutomatic
    End Select

    For Each c In r.Cells
        c.Shading.BackgroundPatternColor = clr
    Next c
End Sub

'==================== MAIN ====================
Public Sub Align_EN_DE_ToTable()
    Dim enPath As String, dePath As String
    enPath = BrowseForFile("Pick English file (PDF or DOCX):")
    If enPath = "" Then Exit Sub
    dePath = BrowseForFile("Pick German file (PDF or DOCX):")
    If dePath = "" Then Exit Sub

    Application.ScreenUpdating = False
    On Error GoTo CleanFail

    Dim enDoc As Document, deDoc As Document
    Set enDoc = OpenAsDocx(enPath)
    Set deDoc = OpenAsDocx(dePath)

    Dim EN() As String, DE() As String
    CollectParagraphs enDoc, EN
    CollectParagraphs deDoc, DE

    ' Drop repeating running headers/footers automatically
    DropRepeatingShortLines EN
    DropRepeatingShortLines DE

    ' Defragment into sentence-like blocks
    DefragmentParas EN
    DefragmentParas DE

    ' Estimate global length ratio
    Dim i As Long, sumEN As Long, sumDE As Long
    For i = LBound(EN) To UBound(EN): sumEN = sumEN + ParaLen(EN(i)): Next
    For i = LBound(DE) To UBound(DE): sumDE = sumDE + ParaLen(DE(i)): Next
    Dim r As Double: If sumEN > 0 Then r = sumDE / sumEN Else r = 1#

    ' DP allocate
    Dim n As Long, M As Long: n = UBound(EN): M = UBound(DE)
    Dim cost() As Double, backA() As Integer, backI() As Long, backJ() As Long
    ReDim cost(0 To n, 0 To M)
    ReDim backA(0 To n, 0 To M)
    ReDim backI(0 To n, 0 To M)
    ReDim backJ(0 To n, 0 To M)

    Dim INF As Double: INF = 1E+30
    Dim j As Long
    For i = 0 To n
        For j = 0 To M: cost(i, j) = INF: Next j
    Next i
    cost(0, 0) = 0

    Dim c As Double
    For i = 0 To n
        For j = 0 To M
            If cost(i, j) < INF Then
                ' 1x1
                If i + 1 <= n And j + 1 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 1, r, 0#)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 1, cost(i, j) + c, 1, i, j
                End If
                ' 1x2
                If i + 1 <= n And j + 2 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 1, j + 1, j + 2, r, PENALTY_1x2)
                    UpdateCell cost, backA, backI, backJ, i + 1, j + 2, cost(i, j) + c, 2, i, j
                End If
                ' 2x1
                If i + 2 <= n And j + 1 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 2, j + 1, j + 1, r, PENALTY_2x1)
                    UpdateCell cost, backA, backI, backJ, i + 2, j + 1, cost(i, j) + c, 3, i, j
                End If
                ' 2x2
                If i + 2 <= n And j + 2 <= M Then
                    c = AlignCost(EN, DE, i + 1, i + 2, j + 1, j + 2, r, PENALTY_2x2)
                    UpdateCell cost, backA, backI, backJ, i + 2, j + 2, cost(i, j) + c, 4, i, j
                End If
                ' Skip EN
                If i + 1 <= n Then
                    c = PENALTY_SKIP_BASE + PENALTY_SKIP_PER_CHAR * ParaLen(EN(i + 1))
                    UpdateCell cost, backA, backI, backJ, i + 1, j, cost(i, j) + c, 5, i, j
                End If
                ' Skip DE
                If j + 1 <= M Then
                    c = PENALTY_SKIP_BASE + PENALTY_SKIP_PER_CHAR * ParaLen(DE(j + 1))
                    UpdateCell cost, backA, backI, backJ, i, j + 1, cost(i, j) + c, 6, i, j
                End If
            End If
        Next j
    Next i

    ' Backtrack
    Dim pairs As New Collection, i1 As Long, j1 As Long, rec As Variant, a As Integer, pi As Long, pj As Long
    i1 = n: j1 = M
    
    ' Check for fail-safe (DP didn't reach the end)
    If cost(i1, j1) >= INF And n > 0 And M > 0 Then
        ' Find the last reachable good cell
        Dim max_k As Double, best_i As Long, best_j As Long
        max_k = -1
        For i = 0 To n
            For j = 0 To M
                If cost(i, j) < INF Then
                    If i + j > max_k Then
                        max_k = i + j
                        best_i = i
                        best_j = j
                    End If
                End If
            Next
        Next
        i1 = best_i
        j1 = best_j
    End If
    
    ' Normal Backtrack from (i1, j1)
    Do While Not (i1 = 0 And j1 = 0)
        a = backA(i1, j1): pi = backI(i1, j1): pj = backJ(i1, j1)
        ' BUG FIX: Reverted to the simpler, correct logic.
        ' The `IIf` logic was incorrect for skip cases.
        rec = Array(a, pi + 1, i1, pj + 1, j1)
        pairs.Add rec
        i1 = pi: j1 = pj
    Loop

    enDoc.Close False: deDoc.Close False

    ' Output
    Dim outDoc As Document: Set outDoc = Documents.Add
    Dim rows As Long: rows = pairs.Count + 1
    Dim tbl As Table
    Set tbl = outDoc.Tables.Add(Range:=outDoc.Range(0, 0), NumRows:=rows, NumColumns:=3)
    tbl.Style = "Table Grid"
    tbl.AutoFitBehavior wdAutoFitWindow
    
    With tbl.Rows(1)
        .Range.Font.Bold = True
        .Shading.BackgroundPatternColor = wdColorGray15
        .Cells(1).Range.Text = "English"
        .Cells(2).Range.Text = "German"
        .Cells(3).Range.Text = "Mapping"
    End With

    Dim k As Long, enFrom As Long, enTo As Long, deFrom As Long, deTo As Long, rowIx As Long, action As Integer
    For k = pairs.Count To 1 Step -1
        rec = pairs(k)
        action = rec(0): enFrom = rec(1): enTo = rec(2): deFrom = rec(3): deTo = rec(4)
        rowIx = pairs.Count - k + 2
        
        tbl.Rows(rowIx).Cells(1).Range.Text = JoinRange(EN, enFrom, enTo)
        tbl.Rows(rowIx).Cells(2).Range.Text = JoinRange(DE, deFrom, deTo)
        tbl.Rows(rowIx).Cells(3).Range.Text = CStr(enFrom) & "-" & enTo & " ? " & deFrom & "-" & deTo
        
        ' REFINED: Color the *entire row*
        Call ColorRow(tbl.Rows(rowIx), action)
    Next
    
    tbl.AutoFitBehavior wdAutoFitContent
    tbl.AutoFitBehavior wdAutoFitWindow

    MsgBox "Alignment complete.", vbInformation

CleanExit:
    Application.ScreenUpdating = True
    Set re = Nothing ' Clean up module-level object
    Exit Sub

CleanFail:
    Application.ScreenUpdating = True
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
    On Error Resume Next
    If Not enDoc Is Nothing Then enDoc.Close False
    If Not deDoc Is Nothing Then deDoc.Close False
    Set re = Nothing ' Clean up module-level object
End Sub
