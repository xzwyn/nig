import graphviz

# --- Create a new Directed Graph ---
dot = graphviz.Digraph(comment='Project Flowchart')
dot.attr(rankdir='TB', label='Translation Alignment & Evaluation Flowchart', fontsize='20')

# --- Define Node Styles (3 Colors, All Rectangles) ---
style_data = {
    'shape': 'box',
    'style': 'filled',
    'fillcolor': 'aliceblue',  # Color 1: Data/IO
    'fontname': 'Helvetica',
}
style_process = {
    'shape': 'box',
    'style': 'filled',
    'fillcolor': 'honeydew',   # Color 2: Processing
    'fontname': 'Helvetica',
}
style_decision = {
    'shape': 'box',            # Using a box as requested
    'style': 'filled',
    'fillcolor': 'seashell', # Color 3: Decisions & AI
    'fontname': 'Helvetica',
}

# --- 1. Start & Inputs ---
dot.node('A', 'Start (User opens Streamlit App)', **style_process)
dot.node('B1', 'Upload English PDF', **style_data)
dot.node('B2', 'Upload German PDF', **style_data)
dot.edge('A', 'B1')
dot.edge('A', 'B2')

# --- 2. Pre-processing Cluster ---
with dot.subgraph(name='cluster_pre') as c:
    c.attr(label='Step 1: Pre-processing', style='filled', color='gray95')
    c.node('C1', 'analyze_pdf (Azure Doc Intelligence)', **style_process)
    c.node('C2', 'analyze_pdf (Azure Doc Intelligence)', **style_process)
    c.node('D1', 'eng_json_data.json', **style_data)
    c.node('D2', 'ger_json_data.json', **style_data)
    c.node('E', 'process_document_json (Stitch & Clean)', **style_process)
    c.node('F', 'full_english_content\nfull_german_content', **style_data)
    
    c.edge('B1', 'C1')
    c.edge('B2', 'C2')
    c.edge('C1', 'D1')
    c.edge('C2', 'D2')
    c.edges([('D1', 'E'), ('D2', 'E')])
    c.edge('E', 'F')

# --- 3. Decision Point ---
dot.node('G', 'Select Alignment Mode?', **style_decision)
dot.edge('F', 'G')

# --- 4A. Path A: ToC-Based Alignment Cluster ---
with dot.subgraph(name='cluster_toc') as c:
    c.attr(label='Step 2A: ToC-Based Alignment', style='filled', color='gray95')
    c.node('H1', 'get_toc_text_from_pdf_bytes', **style_process)
    c.node('H2', 'structure_toc (Regex)', **style_process)
    c.node('H3', 'align_tocs (Hungarian Algorithm)', **style_process)
    c.node('H4', 'aligned_sections', **style_data)
    c.node('H5', 'Loop:\nFor each aligned section...', **style_process)
    c.node('H6', 'Filter content by section pages', **style_process)
    c.node('H7', 'align_content (Semantic Aligner)', **style_process)
    c.node('H8', 'section_pairs', **style_data)
    c.node('H9', 'Collate all section_pairs', **style_process)

    c.edge('H1', 'H2')
    c.edge('H2', 'H3')
    c.edge('H3', 'H4')
    c.edge('H4', 'H5')
    c.edge('H5', 'H6')
    c.edge('H6', 'H7')
    c.edge('H7', 'H8')
    c.edge('H8', 'H5') # Loop back
    c.edge('H5', 'H9')

# Edge from decision to this path
dot.edge('G', 'H1', label='ToC-Based')

# --- 4B. Path B: Full Document Alignment Cluster ---
with dot.subgraph(name='cluster_full') as c:
    c.attr(label='Step 2B: Full Document Alignment', style='filled', color='gray95')
    c.node('I1', 'align_content (Semantic Aligner)\n[on *full* content]', **style_process)
    c.node('I2', 'final_aligned_pairs', **style_data)
    c.edge('I1', 'I2')

# Edge from decision to this path
dot.edge('G', 'I1', label='Full Document')

# --- Merge Point ---
# Node to collect results before evaluation
dot.node('J', 'final_aligned_pairs', **style_data)
dot.edge('H9', 'J')
dot.edge('I2', 'J')

# --- 5. AI Evaluation Pipeline Cluster ---
with dot.subgraph(name='cluster_eval') as c:
    c.attr(label='Step 3: AI Evaluation Pipeline (Loop per pair)', style='filled', color='gray95')
    c.node('K1', 'Agent 1:\nevaluate_translation_pair', **style_decision)
    c.node('K2', 'Agent 2:\n_agent2_validate_finding', **style_decision)
    c.node('K3', 'Agent 3:\ncheck_context_mismatch', **style_decision)
    c.node('K4', 'evaluation_results\n(Confirmed Findings)', **style_data)
    
    c.edge('K1', 'K2', label='Error Found')
    c.edge('K2', 'K3', label='Reject')
    c.edge('K2', 'K4', label='Confirm')
    c.edge('K3', 'K4') # Add result (or lack thereof)

# Edge from alignment to evaluation
dot.edge('J', 'K1')

# --- 6. Reporting Cluster ---
with dot.subgraph(name='cluster_report') as c:
    c.attr(label='Step 4: Reporting', style='filled', color='gray95')
    c.node('L1', 'save_evaluation_report (Excel)', **style_process)
    c.node('L2', 'save_alignment_report (Excel)', **style_process)
    c.node('L3', 'save_sectionwise_debug_report (Excel)\n(if ToC-Based)', **style_process)
    c.node('L4', 'display_results (Streamlit UI)', **style_process)
    c.node('L5', 'create_excel_report_in_memory', **style_process)
    c.node('L6', 'Download Report Button', **style_data)
    
    c.edge('L5', 'L6')

# Edges from evaluation to reporting
dot.edge('K4', 'L1')
dot.edge('K4', 'L4')
dot.edge('J', 'L2') # Alignment report comes from aligned pairs
dot.edge('J', 'L3') # Debug report also comes from aligned pairs
dot.edge('K4', 'L5')

# --- 7. End ---
dot.node('Z', 'End', **style_process)
dot.edge('L4', 'Z')
dot.edge('L6', 'Z')

# --- Render the graph ---
# In Colab, this will display the flowchart inline.
# To save to a file, you can use dot.render('flowchart_name', view=True, format='png')
dot
