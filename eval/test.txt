from typing import List, Dict, Any, Tuple

# Type Alias for clarity
ContentItem = Dict[str, Any]
HeadingPair = Tuple[ContentItem, ContentItem]
AlignedPair = Dict[str, Any] # The final output format for the evaluation pipeline

def _find_content_between(
    start_item: ContentItem, 
    end_item: ContentItem, 
    all_content: List[ContentItem]
) -> str:
    """
    Finds and concatenates all content items between two items,
    based on their character offsets.
    
    --- MODIFIED TO FIX THE "GAP" PROBLEM ---
    This function now stops if it finds another 'rogue' heading
    in the gap, preventing it from merging distinct sections.
    """
    start_offset = start_item['offset']
    end_offset = end_item['offset']
    
    # 1. Find all content items that fall between the two offsets
    content_items_found = [
        item for item in all_content
        if start_offset < item['offset'] < end_offset
    ]
    
    if not content_items_found:
        return ""

    # 2. NEW: Check if any of these items are 'rogue' headings
    rogue_headings = [
        item for item in content_items_found
        if item['type'] in {'title', 'sectionHeading'}
    ]

    final_content_blocks = []
    
    if rogue_headings:
        # 3. If we found rogue headings, only take content *before* the first one
        first_rogue_heading_offset = rogue_headings[0]['offset']
        
        final_content_blocks = [
            item['text'] for item in content_items_found
            if item['offset'] < first_rogue_heading_offset
        ]
        # Log a warning that we stopped an alignment gap
        print(f"  Warning: Found un-validated heading '{rogue_headings[0]['text'][:50]}...' "
              f"between '{start_item['text'][:50]}...' and '{end_item['text'][:50]}...'. "
              "Truncating section to prevent merging.")
    else:
        # 4. If no rogue headings, proceed as normal
        final_content_blocks = [item['text'] for item in content_items_found]
        
    return "\n\n".join(final_content_blocks)

def _find_content_after(
    start_item: ContentItem,
    all_content: List[ContentItem]
) -> str:
    """
    --- NEW FUNCTION ---
    Finds and concatenates all content items *after* the
    last validated heading to the end of the document.
    """
    start_offset = start_item['offset']
    
    content_blocks = [
        item['text'] for item in all_content
        if item['offset'] > start_offset
    ]
    
    return "\n\n".join(content_blocks)


def create_section_pairs(
    validated_heading_pairs: List[HeadingPair],
    full_english_content: List[ContentItem],
    full_german_content: List[ContentItem]
) -> List[AlignedPair]:
    """
    Main orchestration function for Phase 2:
    Uses the validated heading pairs as 'anchors' to extract
    all content *between* them.
    
    --- MODIFIED ---
    Now correctly handles gaps and processes content after the
    final heading.
    """
    if not validated_heading_pairs:
        return []

    print(f"Creating content sections from {len(validated_heading_pairs)} validated heading pairs...")
    
    final_aligned_pairs: List[AlignedPair] = []
    
    # --- 1. Iterate through all consecutive pairs of headings ---
    for i in range(len(validated_heading_pairs) - 1):
        # Current pair (A)
        eng_heading_A, ger_heading_A = validated_heading_pairs[i]
        
        # Next pair (B)
        eng_heading_B, ger_heading_B = validated_heading_pairs[i+1]
        
        # Extract content between A and B for English
        eng_section_text = _find_content_between(
            eng_heading_A, 
            eng_heading_B, 
            full_english_content
        )
        
        # Extract content between A and B for German
        ger_section_text = _find_content_between(
            ger_heading_A, 
            ger_heading_B, 
            full_german_content
        )
        
        # We append all sections, even if both are empty
        # (for back-to-back subheadings)
        final_aligned_pairs.append({
            "english": {
                "text": eng_section_text,
                "type": "section",
                "page": eng_heading_A['page'] # Use start heading page as reference
            },
            "german": {
                "text": ger_section_text,
                "type": "section",
                "page": ger_heading_A['page']
            },
            "similarity": 0.0, # Not applicable in this model
            "margin_score": 0.0 # Not applicable in this model
        })

    # --- 2. NEW: Process content *after* the last heading ---
    # This fixes the "End-of-Document" Omission flaw
    
    print("Processing content after the final validated heading...")
    last_eng_heading, last_ger_heading = validated_heading_pairs[-1]
    
    eng_final_section = _find_content_after(last_eng_heading, full_english_content)
    ger_final_section = _find_content_after(last_ger_heading, full_german_content)

    if eng_final_section or ger_final_section:
        final_aligned_pairs.append({
            "english": {
                "text": eng_final_section,
                "type": "section",
                "page": last_eng_heading['page']
            },
            "german": {
                "text": ger_final_section,
                "type": "section",
                "page": last_ger_heading['page']
            },
            "similarity": 0.0,
            "margin_score": 0.0
        })

    # This number should now be len(validated_heading_pairs)
    print(f"Created {len(final_aligned_pairs)} final section pairs for evaluation.")
    return final_aligned_pairs
